{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"iimrp","text":""},{"location":"#iimrp","title":"iimrp","text":"<p>Magnetic Resonator Piano tools from the Intelligent Instruments Lab.</p>"},{"location":"#supercollider","title":"SuperCollider","text":"<ul> <li>MRP class</li> <li>MRPMIDIKeyboard class</li> </ul>"},{"location":"#tidalcycles","title":"TidalCycles","text":"<ul> <li>MRP OSCTarget definition in Haskell</li> <li><code>mrp.tidal</code> showing usage examples</li> </ul>"},{"location":"#python","title":"Python","text":"<p>The <code>mrp</code> Python package lives in our iil-python-tools repo: http://github.com/Intelligent-Instruments-Lab/iil-python-tools. Follow the instructions there to install it, then read/try the examples in this repo.</p>"},{"location":"#install","title":"Install","text":"<p><code>iimrp</code> can be installed via PyPI:</p> <pre><code>pip install iimrp\n</code></pre>"},{"location":"#develop","title":"Develop","text":"<pre><code>git clone git@github.com:Intelligent-Instruments-Lab/iimrp.git\npip install -e iimrp\n</code></pre>"},{"location":"#contact","title":"Contact","text":"<p><code>iimrp</code> is developed by the Intelligent Instruments Lab. Get in touch to collaborate:</p> <p>\u25e6 iil.is \u25e6  Facebook \u25e6  Instagram \u25e6  X (Twitter) \u25e6  YouTube \u25e6  Discord \u25e6  GitHub \u25e6  LinkedIn \u25e6  Email \u25e6 </p>"},{"location":"#funding","title":"Funding","text":"<p>The Intelligent Instruments project (INTENT) is funded by the European Research Council (ERC) under the European Union\u2019s Horizon 2020 research and innovation programme (Grant agreement No. 101001848).</p>"},{"location":"reference/iimrp/__init__/","title":"init","text":""},{"location":"reference/iimrp/iimrp/","title":"Iimrp","text":"Authors <p>Victor Shepardson Jack Armitage Intelligent Instruments Lab 2022</p>"},{"location":"reference/iimrp/iimrp/#iimrp.iimrp.MRP","title":"<code>MRP</code>","text":"<p>             Bases: <code>object</code></p> Source code in <code>src/iimrp/iimrp.py</code> <pre><code>class MRP(object):\n\n    def print(self, *a, **kw):\n        if self.verbose:\n            print(*a, **kw)\n\n    def __init__(self, _osc, settings=None, verbose=True):\n        # default settings\n        self.verbose = verbose\n        self.settings = {\n            'address': {\n                'port': 7770,\n                'ip': '127.0.0.1'\n            },\n            'voices': {\n                'max': 16, # for 16 cables\n                'rule': 'oldest' # oldest, lowest, highest, quietest...\n            },\n            'channel': 15, # real-time midi note ch (0-indexed)\n            'range': { 'start': 21, 'end': 108 }, # MIDI for piano keys 0-88\n            'qualities_max': 1.0,\n            'qualities_min': 0.0\n        }\n        self.note_on_hex = 0x9F\n        self.note_off_hex = 0x8F\n        # custom settings\n        if settings is not None:\n            for k, v in settings.items():\n                self.settings[k] = v\n        self.print('MRP starting with settings:', self.settings)\n\n        # OSC reference and paths\n        self.osc = _osc\n        assert self.osc.get_client_by_name(\"mrp\") is not None, f\"OSC client 'mrp' not found in: {_osc.client_names}\"\n        self.osc_paths = {\n            'midi': '/mrp/midi',\n            'qualities': {\n                'brightness':    '/mrp/quality/brightness',\n                'intensity':     '/mrp/quality/intensity',\n                'pitch':         '/mrp/quality/pitch',\n                'pitch_vibrato': '/mrp/quality/pitch/vibrato',\n                'harmonic':      '/mrp/quality/harmonic',\n                'harmonics_raw': '/mrp/quality/harmonics/raw'\n            },\n            'pedal': {\n                'damper':    '/mrp/pedal/damper',\n                'sostenuto': '/mrp/pedal/sostenuto'\n            },\n            'misc': {\n                'allnotesoff': '/mrp/allnotesoff'\n            },\n            'ui': {\n                'volume':     '/ui/volume', # float vol // 0-1, &gt;0.5 ? 4^((vol-0.5)/0.5) : 10^((vol-0.5)/0.5)\n                'volume_raw': '/ui/volume/raw' # float vol // 0-1, set volume directly\n            }\n        }\n        # internal state\n        self.notes = [] # state of each real-time midi note\n        self.note = { # template note\n            'channel': self.settings['channel'],\n            'status': NOTE_OFF,\n            'midi': {\n                'number': 0, # MIDI note number, not piano key number\n                'velocity': 0, # not in use by MRP PLL synth\n                'aftertouch_poly': 0, # not in use by MRP PLL synth\n                'aftertouch_channel': 0, # not in use by MRP PLL synth\n                'pitch_bend': 0 # not in use by MRP PLL synth\n            },\n            'qualities': {\n                'brightness': 0,\n                'intensity': 0,\n                'pitch': 0,\n                'pitch_vibrato': 0,\n                'harmonic': 0,\n                'harmonics_raw': []\n            }\n        }\n        self.voices = [] # active notes indexed chronologically\n        self.pedal = {\n            'damper': 0,\n            'sostenuto': 0\n        }\n        self.ui = {\n            'volume': 0,\n            'volume_raw': 0\n        }\n        self.program = 0 # current program (see MRP XML)\n        # init sequence\n        self.init_notes()\n\n    def init_notes(self):\n        \"\"\"\n        initialise an array of notes in NOTE_OFF state,\n        equal in length to the number of piano keys in use\n        \"\"\"\n        self.notes = []\n        piano_keys = self.settings['range']['end'] - \\\n                     self.settings['range']['start'] + 1 # inclusive\n        for k in range(piano_keys):\n            note = self.note_create(\n                self.settings['range']['start'] + k, # MIDI note numbers\n                0\n            )\n            self.notes.append(note)\n        self.print(len(self.notes), 'notes created.')\n\n    \"\"\"\n    /mrp/midi\n    \"\"\"\n    def note_on(self, note, velocity=1, channel=None):\n        \"\"\"\n        check if note on is valid\n        add it as an active voice\n        construct a Note On message &amp; send over OSC\n        \"\"\"\n        if self.note_on_is_valid(note) == True:\n            self.voices_add(note)\n            if channel is None:\n                channel = self.settings['channel']\n            tmp = self.notes[self.note_index(note)]\n            tmp['status'] = NOTE_ON\n            tmp['channel'] = channel\n            tmp['midi']['velocity'] = velocity\n            path = self.osc_paths['midi']\n            self.print(path, 'Note On:', note, ', Velocity:', velocity)\n            self.osc.send(path, self.note_on_hex, note, velocity, client=\"mrp\")\n            return tmp\n        else:\n            self.print('note_on(): invalid Note On', note)\n            return None\n\n    def note_off(self, note, velocity=0, channel=None):\n        \"\"\"\n        check if note off is valid\n        remove it as an active voice\n        construct a Note Off message &amp; send over OSC\n        \"\"\"\n        if self.note_off_is_valid(note) == True:\n            if note in self.voices:\n                self.voices_remove(note)\n            if channel is None:\n                channel = self.settings['channel']\n            tmp = self.notes[self.note_index(note)]\n            tmp['status'] = NOTE_OFF\n            tmp['channel'] = channel\n            tmp['midi']['velocity'] = velocity\n            path = self.osc_paths['midi']\n            self.print(path, 'Note Off:', note)\n            self.osc.send(path, self.note_off_hex, note, velocity, client=\"mrp\")\n            return tmp\n        else:\n            self.print('note_off(): invalid Note Off', note)\n            return None\n\n    def notes_on(self, notes, velocities=None):\n        vmax = self.settings['voices']['max']\n        if len(notes)+1 &gt; vmax:\n            if velocities == None:\n                [self.note_on(n) for n in notes]\n            else:\n                [self.note_on(n, velocities[i]) for i,n in enumerate(notes)]\n        else:\n            print('notes_on(): too many notes', notes)\n\n    def notes_off(self, notes, channel=None):\n        [self.note_off(n) for n in notes]\n\n    # def control_change(self, controller, value, channel=None):\n    #     \"\"\"\n    #     construct MIDI CC message &amp; send over OSC\n    #     \"\"\"\n    #     if channel is None:\n    #         channel = self.settings['channel']\n    #     m = mido.Message(\n    #         'control_change',\n    #         channel=channel,\n    #         controller=controller,\n    #         value=value\n    #     )\n    #     path = self.osc_paths['midi']\n    #     self.print(path, 'Control Change:', *m.bytes())\n    #     self.osc.send(path, *m.bytes(), client=\"mrp\")\n\n    # def program_change(self, program, channel=None):\n    #     \"\"\"\n    #     update program state\n    #     construct MIDI program change message \n    #     &amp; send over OSC\n    #     \"\"\"\n    #     if channel is None:\n    #         channel = self.settings['channel']\n    #     self.program = program\n    #     m = mido.Message(\n    #         'program_change',\n    #         channel=channel,\n    #         program=program\n    #     )\n    #     path = self.osc_paths['midi']\n    #     self.print(path, 'Program Change:', *m.bytes())\n    #     self.osc.send(path, *m.bytes(), client=\"mrp\")\n\n    \"\"\"\n    /mrp/qualities\n    \"\"\"\n    def quality_update(self, note: int, quality: str, value: float, relative=False, channel=None):\n        \"\"\"\n        Update a note's quality to a new value.\n\n        Example\n            quality_update(48, 'brightness', 0.5)\n\n        Args\n            note (int): MIDI note number\n            quality (string): name of quality to update, must be same as key in osc_paths\n            value (float): value of quality\n            relative (bool): replace the value or add it to the current value\n            channel (int): which MIDI channel to send on\n        \"\"\"\n        if isinstance(quality, str):\n            if self.note_msg_is_valid(note) == True:\n                if channel is None:\n                    channel = self.settings['channel']\n                tmp = self.notes[self.note_index(note)]\n                if isinstance(value, list) or isinstance(value, np.ndarray): # e.g. /harmonics/raw\n                    if relative is True:\n                        self.print('quality_update(): relative updating of lists not supported')\n                        # if (len(tmp['qualities'][quality]) &gt; 0):\n                        #     for i, q in enumerate(tmp['qualities'][quality]):\n                        #         tmp['qualities'][quality][i] += self.quality_clamp(value[i])\n                        #         value.pop(i)\n                        #     for i, v in enumerate(value):\n                        #         tmp['qualities'][quality].append(value[i])\n                        # else:\n                        #     tmp['qualities'][quality] = [self.quality_clamp(v) for v in value]\n                    else:\n                        tmp['qualities'][quality] = [self.quality_clamp(v) for v in value]\n                    path = self.osc_paths['qualities'][quality]\n                    self.print(path, channel, note, *tmp['qualities'][quality])\n                    self.osc.send(path, channel, note, *tmp['qualities'][quality], client=\"mrp\")\n                    return tmp\n                else:\n                    if relative is True:\n                        tmp['qualities'][quality] = self.quality_clamp(value + tmp['qualities'][quality])\n                    else:\n                        tmp['qualities'][quality] = self.quality_clamp(value)\n                    path = self.osc_paths['qualities'][quality]\n                    self.print(path, channel, note, tmp['qualities'][quality])\n                    self.osc.send(path, channel, note, tmp['qualities'][quality], client=\"mrp\")\n                    return tmp\n            else:\n                self.print('quality_update(): invalid message:', quality, note, value)\n                return None\n        else:\n            self.print('quality_update(): \"quality\" is not a string:', quality)\n            return None\n\n    def qualities_update(self, note, qualities, relative=False, channel=None):\n        \"\"\"\n        Update a note's qualities to a new set of values.\n\n        Example\n            qualities_update(48, {\n                'brightness': 0.5,\n                'intensity': 0.6,\n                'harmonics_raw': [0.2, 0.3, 0.4]\n            })\n\n        Args\n            note (int): MIDI note number\n            qualities (dict): dict of qualities in key (string):value (float) pairs to update, \n                              must be same as key in osc_paths\n            relative (bool): replace the value or add it to the current value\n            channel (int): which MIDI channel to send on\n        \"\"\"\n        if isinstance(qualities, dict):\n            if self.note_msg_is_valid(note) == True:\n                if channel is None:\n                    channel = self.settings['channel']\n                tmp = self.notes[self.note_index(note)]\n                for q, v in qualities.items():\n                    if isinstance(v, list) or isinstance(v, np.ndarray): # e.g. /harmonics/raw\n                        if relative is True:\n                            self.print('quality_update(): relative updating of lists not supported')\n                        else:\n                            tmp['qualities'][q] = [self.quality_clamp(i) for i in v]\n                        path = self.osc_paths['qualities'][q]\n                        self.print(path, channel, note, *tmp['qualities'][q])\n                        self.osc.send(path, channel, note, *tmp['qualities'][q], client=\"mrp\")\n                    else:\n                        if relative is True:\n                            tmp['qualities'][q] = self.quality_clamp(v, tmp['qualities'][q])\n                        else:\n                            tmp['qualities'][q] = self.quality_clamp(v)\n                        path = self.osc_paths['qualities'][q]\n                        self.print(path, channel, note, tmp['qualities'][q])\n                        self.osc.send(path, channel, note, tmp['qualities'][q], client=\"mrp\")\n                return tmp\n            else:\n                self.print('quality_update(): invalid message:', note, qualities)\n                return None\n        else:\n            self.print('quality_update(): \"qualities\" is not an object:', note, qualities)\n            return None\n\n    \"\"\"\n    /mrp/pedal\n    \"\"\"\n    def pedal_sostenuto(self, sostenuto):\n        \"\"\"\n        set pedal sostenuto value\n        \"\"\"\n        self.pedal.sostenuto = sostenuto\n        path = self.osc_paths['pedal']['sostenuto']\n        self.print(path, sostenuto)\n        self.osc.send(path, sostenuto, client=\"mrp\")\n\n    def pedal_damper(self, damper):\n        \"\"\"\n        set pedal damper value\n        \"\"\"\n        self.pedal.damper = damper\n        path = self.osc_paths['pedal']['damper']\n        self.print(path, damper)\n        self.osc.send(path, damper, client=\"mrp\")\n\n    \"\"\"\n    /mrp/* miscellaneous\n    \"\"\"\n    def all_notes_off(self):\n        \"\"\"\n        turn all notes off\n        \"\"\"\n        path = self.osc_paths['misc']['allnotesoff']\n        self.print(path)\n        self.osc.send(path, client=\"mrp\")\n        self.init_notes()\n        self.voices_reset()\n\n    \"\"\"\n    /mrp/ui\n    \"\"\"\n    def ui_volume(self, value):\n        \"\"\"\n        float vol // 0-1, &gt;0.5 ? 4^((vol-0.5)/0.5) : 10^((vol-0.5)/0.5)\n        \"\"\"\n        self.ui.volume = value\n        path = self.osc_paths['ui']['volume']\n        self.print(path, value)\n        self.osc.send(path, value, client=\"mrp\")\n\n    def ui_volume_raw(self, value):\n        \"\"\"\n        float vol // 0-1, set volume directly\n        \"\"\"\n        self.ui.volume_raw = value\n        path = self.osc_paths['ui']['volume_raw']\n        self.print(path, value)\n        self.osc.send(path, value, client=\"mrp\")\n\n    \"\"\"\n    note methods\n    \"\"\"\n    def note_create(self, n, velocity, channel=None):\n        \"\"\"\n        create and return a note object\n        \"\"\"\n        if channel is None:\n            channel = self.settings['channel']\n        note = copy.deepcopy(self.note)\n        note['midi']['number'] = n\n        note['midi']['velocity'] = velocity\n        return note\n\n    def note_is_in_range(self, note):\n        \"\"\"\n        check if a note is in valid range\n        \"\"\"\n        start = self.settings['range']['start']\n        end = self.settings['range']['end']\n        if start &gt; note or note &gt; end:\n            return False\n        return True\n\n    def note_is_off(self, note):\n        \"\"\"\n        check if a note is off\n        \"\"\"\n        index = note - self.settings['range']['start']\n        if self.notes[index]['status'] == NOTE_ON:\n            return False\n        return True\n\n    def note_index(self, note):\n        return note - self.settings['range']['start']\n\n    def note_on_numbers(self):\n        \"\"\"\n        return numbers of notes that are on\n        \"\"\"\n        return [\n            note['midi']['number'] \n            for note in self.notes \n            if note['status']==NOTE_ON]\n\n    def note_on_is_valid(self, note):\n        \"\"\"\n        check if the note is on &amp; in range\n        \"\"\"\n        if self.note_is_in_range(note) == True:\n            if self.note_is_off(note) == True:\n                return True\n            else:\n                self.print('note_on_is_valid(): note', note, 'is already on')\n                return False\n        else:\n            self.print('note_on_is_valid(): note', note, 'out of range')\n            return False\n\n\n    def note_msg_is_valid(self, note):\n        return self.note_off_is_valid(note)\n\n    def note_off_is_valid(self, note):\n        \"\"\"\n        check if the note is off &amp; in range\n        \"\"\"\n        if self.note_is_off(note) == False:\n            if self.note_is_in_range(note) == True:\n                return True\n            else:\n                self.print('note_off_is_valid(): note', note, 'out of range')\n                return False\n        else:\n            self.print('note_off_is_valid(): note', note, 'is already off')\n            return False\n\n    \"\"\"\n    qualities methods\n    \"\"\"\n    def quality_clamp(self, value):\n        ### NOTE pitch, at least, can be negative or &gt; 1\n        return float(value)\n        # return float(clamp(value, self.settings['qualities_min'], self.settings['qualities_max']))\n\n    \"\"\"\n    voice methods\n    \"\"\"\n    def voices_add(self, note):\n        \"\"\"\n        add voices up to the maximum\n        then replace voices based on the rule\n        \"\"\"\n        if note in self.voices:\n            self.print('voices_add(): note already active')\n            return self.voices\n        if self.voices_count() &lt; self.settings['voices']['max']:\n            self.voices.append(note)\n        else:\n            rule = self.settings['voices']['rule']\n            match rule:\n                case 'oldest':\n                    oldest = self.voices[0]\n                    self.print('voices_add(): removing oldest', oldest)\n                    self.voices.pop(0)\n                    self.voices.append(note)\n                    self.note_off(oldest)\n                    return self.voices\n                case _: # lowest, highest, quietest, ...\n                    return self.voices\n        return self.voices\n\n    def voices_remove(self, note):\n        self.voices.remove(note)\n        return self.voices\n\n    def voices_update(self):\n        \"\"\"\n        reconstruct active voices list based on self.notes\n        \"\"\"\n        self.voices = self.note_on_numbers()\n        return self.voices\n\n    def voices_compare(self):\n        \"\"\"\n        check if voices and notes match\n        \"\"\"\n        note_on_numbers = self.note_on_numbers()\n        return note_on_numbers == self.voices, {'notes': note_on_numbers}, {'voices': self.voices}\n\n    def voices_reset(self):\n        self.voices = []\n\n    def voices_count(self):\n        return len(self.voices)\n\n    def voices_position(self, note):\n        \"\"\"\n        return position of a note in voice queue\n        \"\"\"\n        if note in self.voices:\n            return self.voices.index(note)\n        else:\n            self.print('voices_note_age(): note', note, 'is off')\n            return -1\n\n    '''\n    Getter utils\n    '''\n\n    def get_notes_on(self):\n        return [n['midi']['number'] for n in self.notes if n['status']==NOTE_ON]\n\n    def get_notes_status(self):\n        # return a dict of midi_number:status for all notes:\n        return {n['midi']['number']:n['status'] for n in self.notes}\n\n    def get_notes_harmonics(self):\n        return {n['midi']['number']:n['qualities']['harmonics_raw'] for n in self.notes}\n\n    \"\"\"\n    misc methods\n    \"\"\"\n    def cleanup(self):\n        print('MRP exiting...')\n        self.all_notes_off()\n</code></pre>"},{"location":"reference/iimrp/iimrp/#iimrp.iimrp.MRP.all_notes_off","title":"<code>all_notes_off()</code>","text":"<p>turn all notes off</p> Source code in <code>src/iimrp/iimrp.py</code> <pre><code>def all_notes_off(self):\n    \"\"\"\n    turn all notes off\n    \"\"\"\n    path = self.osc_paths['misc']['allnotesoff']\n    self.print(path)\n    self.osc.send(path, client=\"mrp\")\n    self.init_notes()\n    self.voices_reset()\n</code></pre>"},{"location":"reference/iimrp/iimrp/#iimrp.iimrp.MRP.init_notes","title":"<code>init_notes()</code>","text":"<p>initialise an array of notes in NOTE_OFF state, equal in length to the number of piano keys in use</p> Source code in <code>src/iimrp/iimrp.py</code> <pre><code>def init_notes(self):\n    \"\"\"\n    initialise an array of notes in NOTE_OFF state,\n    equal in length to the number of piano keys in use\n    \"\"\"\n    self.notes = []\n    piano_keys = self.settings['range']['end'] - \\\n                 self.settings['range']['start'] + 1 # inclusive\n    for k in range(piano_keys):\n        note = self.note_create(\n            self.settings['range']['start'] + k, # MIDI note numbers\n            0\n        )\n        self.notes.append(note)\n    self.print(len(self.notes), 'notes created.')\n</code></pre>"},{"location":"reference/iimrp/iimrp/#iimrp.iimrp.MRP.note_create","title":"<code>note_create(n, velocity, channel=None)</code>","text":"<p>create and return a note object</p> Source code in <code>src/iimrp/iimrp.py</code> <pre><code>def note_create(self, n, velocity, channel=None):\n    \"\"\"\n    create and return a note object\n    \"\"\"\n    if channel is None:\n        channel = self.settings['channel']\n    note = copy.deepcopy(self.note)\n    note['midi']['number'] = n\n    note['midi']['velocity'] = velocity\n    return note\n</code></pre>"},{"location":"reference/iimrp/iimrp/#iimrp.iimrp.MRP.note_is_in_range","title":"<code>note_is_in_range(note)</code>","text":"<p>check if a note is in valid range</p> Source code in <code>src/iimrp/iimrp.py</code> <pre><code>def note_is_in_range(self, note):\n    \"\"\"\n    check if a note is in valid range\n    \"\"\"\n    start = self.settings['range']['start']\n    end = self.settings['range']['end']\n    if start &gt; note or note &gt; end:\n        return False\n    return True\n</code></pre>"},{"location":"reference/iimrp/iimrp/#iimrp.iimrp.MRP.note_is_off","title":"<code>note_is_off(note)</code>","text":"<p>check if a note is off</p> Source code in <code>src/iimrp/iimrp.py</code> <pre><code>def note_is_off(self, note):\n    \"\"\"\n    check if a note is off\n    \"\"\"\n    index = note - self.settings['range']['start']\n    if self.notes[index]['status'] == NOTE_ON:\n        return False\n    return True\n</code></pre>"},{"location":"reference/iimrp/iimrp/#iimrp.iimrp.MRP.note_off","title":"<code>note_off(note, velocity=0, channel=None)</code>","text":"<p>check if note off is valid remove it as an active voice construct a Note Off message &amp; send over OSC</p> Source code in <code>src/iimrp/iimrp.py</code> <pre><code>def note_off(self, note, velocity=0, channel=None):\n    \"\"\"\n    check if note off is valid\n    remove it as an active voice\n    construct a Note Off message &amp; send over OSC\n    \"\"\"\n    if self.note_off_is_valid(note) == True:\n        if note in self.voices:\n            self.voices_remove(note)\n        if channel is None:\n            channel = self.settings['channel']\n        tmp = self.notes[self.note_index(note)]\n        tmp['status'] = NOTE_OFF\n        tmp['channel'] = channel\n        tmp['midi']['velocity'] = velocity\n        path = self.osc_paths['midi']\n        self.print(path, 'Note Off:', note)\n        self.osc.send(path, self.note_off_hex, note, velocity, client=\"mrp\")\n        return tmp\n    else:\n        self.print('note_off(): invalid Note Off', note)\n        return None\n</code></pre>"},{"location":"reference/iimrp/iimrp/#iimrp.iimrp.MRP.note_off_is_valid","title":"<code>note_off_is_valid(note)</code>","text":"<p>check if the note is off &amp; in range</p> Source code in <code>src/iimrp/iimrp.py</code> <pre><code>def note_off_is_valid(self, note):\n    \"\"\"\n    check if the note is off &amp; in range\n    \"\"\"\n    if self.note_is_off(note) == False:\n        if self.note_is_in_range(note) == True:\n            return True\n        else:\n            self.print('note_off_is_valid(): note', note, 'out of range')\n            return False\n    else:\n        self.print('note_off_is_valid(): note', note, 'is already off')\n        return False\n</code></pre>"},{"location":"reference/iimrp/iimrp/#iimrp.iimrp.MRP.note_on","title":"<code>note_on(note, velocity=1, channel=None)</code>","text":"<p>check if note on is valid add it as an active voice construct a Note On message &amp; send over OSC</p> Source code in <code>src/iimrp/iimrp.py</code> <pre><code>def note_on(self, note, velocity=1, channel=None):\n    \"\"\"\n    check if note on is valid\n    add it as an active voice\n    construct a Note On message &amp; send over OSC\n    \"\"\"\n    if self.note_on_is_valid(note) == True:\n        self.voices_add(note)\n        if channel is None:\n            channel = self.settings['channel']\n        tmp = self.notes[self.note_index(note)]\n        tmp['status'] = NOTE_ON\n        tmp['channel'] = channel\n        tmp['midi']['velocity'] = velocity\n        path = self.osc_paths['midi']\n        self.print(path, 'Note On:', note, ', Velocity:', velocity)\n        self.osc.send(path, self.note_on_hex, note, velocity, client=\"mrp\")\n        return tmp\n    else:\n        self.print('note_on(): invalid Note On', note)\n        return None\n</code></pre>"},{"location":"reference/iimrp/iimrp/#iimrp.iimrp.MRP.note_on_is_valid","title":"<code>note_on_is_valid(note)</code>","text":"<p>check if the note is on &amp; in range</p> Source code in <code>src/iimrp/iimrp.py</code> <pre><code>def note_on_is_valid(self, note):\n    \"\"\"\n    check if the note is on &amp; in range\n    \"\"\"\n    if self.note_is_in_range(note) == True:\n        if self.note_is_off(note) == True:\n            return True\n        else:\n            self.print('note_on_is_valid(): note', note, 'is already on')\n            return False\n    else:\n        self.print('note_on_is_valid(): note', note, 'out of range')\n        return False\n</code></pre>"},{"location":"reference/iimrp/iimrp/#iimrp.iimrp.MRP.note_on_numbers","title":"<code>note_on_numbers()</code>","text":"<p>return numbers of notes that are on</p> Source code in <code>src/iimrp/iimrp.py</code> <pre><code>def note_on_numbers(self):\n    \"\"\"\n    return numbers of notes that are on\n    \"\"\"\n    return [\n        note['midi']['number'] \n        for note in self.notes \n        if note['status']==NOTE_ON]\n</code></pre>"},{"location":"reference/iimrp/iimrp/#iimrp.iimrp.MRP.pedal_damper","title":"<code>pedal_damper(damper)</code>","text":"<p>set pedal damper value</p> Source code in <code>src/iimrp/iimrp.py</code> <pre><code>def pedal_damper(self, damper):\n    \"\"\"\n    set pedal damper value\n    \"\"\"\n    self.pedal.damper = damper\n    path = self.osc_paths['pedal']['damper']\n    self.print(path, damper)\n    self.osc.send(path, damper, client=\"mrp\")\n</code></pre>"},{"location":"reference/iimrp/iimrp/#iimrp.iimrp.MRP.pedal_sostenuto","title":"<code>pedal_sostenuto(sostenuto)</code>","text":"<p>set pedal sostenuto value</p> Source code in <code>src/iimrp/iimrp.py</code> <pre><code>def pedal_sostenuto(self, sostenuto):\n    \"\"\"\n    set pedal sostenuto value\n    \"\"\"\n    self.pedal.sostenuto = sostenuto\n    path = self.osc_paths['pedal']['sostenuto']\n    self.print(path, sostenuto)\n    self.osc.send(path, sostenuto, client=\"mrp\")\n</code></pre>"},{"location":"reference/iimrp/iimrp/#iimrp.iimrp.MRP.qualities_update","title":"<code>qualities_update(note, qualities, relative=False, channel=None)</code>","text":"<p>Update a note's qualities to a new set of values.</p> <p>Example     qualities_update(48, {         'brightness': 0.5,         'intensity': 0.6,         'harmonics_raw': [0.2, 0.3, 0.4]     })</p> <p>Args     note (int): MIDI note number     qualities (dict): dict of qualities in key (string):value (float) pairs to update,                        must be same as key in osc_paths     relative (bool): replace the value or add it to the current value     channel (int): which MIDI channel to send on</p> Source code in <code>src/iimrp/iimrp.py</code> <pre><code>def qualities_update(self, note, qualities, relative=False, channel=None):\n    \"\"\"\n    Update a note's qualities to a new set of values.\n\n    Example\n        qualities_update(48, {\n            'brightness': 0.5,\n            'intensity': 0.6,\n            'harmonics_raw': [0.2, 0.3, 0.4]\n        })\n\n    Args\n        note (int): MIDI note number\n        qualities (dict): dict of qualities in key (string):value (float) pairs to update, \n                          must be same as key in osc_paths\n        relative (bool): replace the value or add it to the current value\n        channel (int): which MIDI channel to send on\n    \"\"\"\n    if isinstance(qualities, dict):\n        if self.note_msg_is_valid(note) == True:\n            if channel is None:\n                channel = self.settings['channel']\n            tmp = self.notes[self.note_index(note)]\n            for q, v in qualities.items():\n                if isinstance(v, list) or isinstance(v, np.ndarray): # e.g. /harmonics/raw\n                    if relative is True:\n                        self.print('quality_update(): relative updating of lists not supported')\n                    else:\n                        tmp['qualities'][q] = [self.quality_clamp(i) for i in v]\n                    path = self.osc_paths['qualities'][q]\n                    self.print(path, channel, note, *tmp['qualities'][q])\n                    self.osc.send(path, channel, note, *tmp['qualities'][q], client=\"mrp\")\n                else:\n                    if relative is True:\n                        tmp['qualities'][q] = self.quality_clamp(v, tmp['qualities'][q])\n                    else:\n                        tmp['qualities'][q] = self.quality_clamp(v)\n                    path = self.osc_paths['qualities'][q]\n                    self.print(path, channel, note, tmp['qualities'][q])\n                    self.osc.send(path, channel, note, tmp['qualities'][q], client=\"mrp\")\n            return tmp\n        else:\n            self.print('quality_update(): invalid message:', note, qualities)\n            return None\n    else:\n        self.print('quality_update(): \"qualities\" is not an object:', note, qualities)\n        return None\n</code></pre>"},{"location":"reference/iimrp/iimrp/#iimrp.iimrp.MRP.quality_update","title":"<code>quality_update(note, quality, value, relative=False, channel=None)</code>","text":"<p>Update a note's quality to a new value.</p> <p>Example     quality_update(48, 'brightness', 0.5)</p> <p>Args     note (int): MIDI note number     quality (string): name of quality to update, must be same as key in osc_paths     value (float): value of quality     relative (bool): replace the value or add it to the current value     channel (int): which MIDI channel to send on</p> Source code in <code>src/iimrp/iimrp.py</code> <pre><code>def quality_update(self, note: int, quality: str, value: float, relative=False, channel=None):\n    \"\"\"\n    Update a note's quality to a new value.\n\n    Example\n        quality_update(48, 'brightness', 0.5)\n\n    Args\n        note (int): MIDI note number\n        quality (string): name of quality to update, must be same as key in osc_paths\n        value (float): value of quality\n        relative (bool): replace the value or add it to the current value\n        channel (int): which MIDI channel to send on\n    \"\"\"\n    if isinstance(quality, str):\n        if self.note_msg_is_valid(note) == True:\n            if channel is None:\n                channel = self.settings['channel']\n            tmp = self.notes[self.note_index(note)]\n            if isinstance(value, list) or isinstance(value, np.ndarray): # e.g. /harmonics/raw\n                if relative is True:\n                    self.print('quality_update(): relative updating of lists not supported')\n                    # if (len(tmp['qualities'][quality]) &gt; 0):\n                    #     for i, q in enumerate(tmp['qualities'][quality]):\n                    #         tmp['qualities'][quality][i] += self.quality_clamp(value[i])\n                    #         value.pop(i)\n                    #     for i, v in enumerate(value):\n                    #         tmp['qualities'][quality].append(value[i])\n                    # else:\n                    #     tmp['qualities'][quality] = [self.quality_clamp(v) for v in value]\n                else:\n                    tmp['qualities'][quality] = [self.quality_clamp(v) for v in value]\n                path = self.osc_paths['qualities'][quality]\n                self.print(path, channel, note, *tmp['qualities'][quality])\n                self.osc.send(path, channel, note, *tmp['qualities'][quality], client=\"mrp\")\n                return tmp\n            else:\n                if relative is True:\n                    tmp['qualities'][quality] = self.quality_clamp(value + tmp['qualities'][quality])\n                else:\n                    tmp['qualities'][quality] = self.quality_clamp(value)\n                path = self.osc_paths['qualities'][quality]\n                self.print(path, channel, note, tmp['qualities'][quality])\n                self.osc.send(path, channel, note, tmp['qualities'][quality], client=\"mrp\")\n                return tmp\n        else:\n            self.print('quality_update(): invalid message:', quality, note, value)\n            return None\n    else:\n        self.print('quality_update(): \"quality\" is not a string:', quality)\n        return None\n</code></pre>"},{"location":"reference/iimrp/iimrp/#iimrp.iimrp.MRP.ui_volume","title":"<code>ui_volume(value)</code>","text":"<p>float vol // 0-1, &gt;0.5 ? 4^((vol-0.5)/0.5) : 10^((vol-0.5)/0.5)</p> Source code in <code>src/iimrp/iimrp.py</code> <pre><code>def ui_volume(self, value):\n    \"\"\"\n    float vol // 0-1, &gt;0.5 ? 4^((vol-0.5)/0.5) : 10^((vol-0.5)/0.5)\n    \"\"\"\n    self.ui.volume = value\n    path = self.osc_paths['ui']['volume']\n    self.print(path, value)\n    self.osc.send(path, value, client=\"mrp\")\n</code></pre>"},{"location":"reference/iimrp/iimrp/#iimrp.iimrp.MRP.ui_volume_raw","title":"<code>ui_volume_raw(value)</code>","text":"<p>float vol // 0-1, set volume directly</p> Source code in <code>src/iimrp/iimrp.py</code> <pre><code>def ui_volume_raw(self, value):\n    \"\"\"\n    float vol // 0-1, set volume directly\n    \"\"\"\n    self.ui.volume_raw = value\n    path = self.osc_paths['ui']['volume_raw']\n    self.print(path, value)\n    self.osc.send(path, value, client=\"mrp\")\n</code></pre>"},{"location":"reference/iimrp/iimrp/#iimrp.iimrp.MRP.voices_add","title":"<code>voices_add(note)</code>","text":"<p>add voices up to the maximum then replace voices based on the rule</p> Source code in <code>src/iimrp/iimrp.py</code> <pre><code>def voices_add(self, note):\n    \"\"\"\n    add voices up to the maximum\n    then replace voices based on the rule\n    \"\"\"\n    if note in self.voices:\n        self.print('voices_add(): note already active')\n        return self.voices\n    if self.voices_count() &lt; self.settings['voices']['max']:\n        self.voices.append(note)\n    else:\n        rule = self.settings['voices']['rule']\n        match rule:\n            case 'oldest':\n                oldest = self.voices[0]\n                self.print('voices_add(): removing oldest', oldest)\n                self.voices.pop(0)\n                self.voices.append(note)\n                self.note_off(oldest)\n                return self.voices\n            case _: # lowest, highest, quietest, ...\n                return self.voices\n    return self.voices\n</code></pre>"},{"location":"reference/iimrp/iimrp/#iimrp.iimrp.MRP.voices_compare","title":"<code>voices_compare()</code>","text":"<p>check if voices and notes match</p> Source code in <code>src/iimrp/iimrp.py</code> <pre><code>def voices_compare(self):\n    \"\"\"\n    check if voices and notes match\n    \"\"\"\n    note_on_numbers = self.note_on_numbers()\n    return note_on_numbers == self.voices, {'notes': note_on_numbers}, {'voices': self.voices}\n</code></pre>"},{"location":"reference/iimrp/iimrp/#iimrp.iimrp.MRP.voices_position","title":"<code>voices_position(note)</code>","text":"<p>return position of a note in voice queue</p> Source code in <code>src/iimrp/iimrp.py</code> <pre><code>def voices_position(self, note):\n    \"\"\"\n    return position of a note in voice queue\n    \"\"\"\n    if note in self.voices:\n        return self.voices.index(note)\n    else:\n        self.print('voices_note_age(): note', note, 'is off')\n        return -1\n</code></pre>"},{"location":"reference/iimrp/iimrp/#iimrp.iimrp.MRP.voices_update","title":"<code>voices_update()</code>","text":"<p>reconstruct active voices list based on self.notes</p> Source code in <code>src/iimrp/iimrp.py</code> <pre><code>def voices_update(self):\n    \"\"\"\n    reconstruct active voices list based on self.notes\n    \"\"\"\n    self.voices = self.note_on_numbers()\n    return self.voices\n</code></pre>"}]}