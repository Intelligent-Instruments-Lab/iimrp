{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"iimrp","text":""},{"location":"#iimrp","title":"iimrp","text":"<p>Magnetic Resonator Piano tools from the Intelligent Instruments Lab.</p>"},{"location":"#supercollider","title":"SuperCollider","text":"<ul> <li>MRP class</li> <li>MRPMIDIKeyboard class</li> </ul>"},{"location":"#tidalcycles","title":"TidalCycles","text":"<ul> <li>MRP OSCTarget definition in Haskell</li> <li><code>mrp.tidal</code> showing usage examples</li> </ul>"},{"location":"#max-msp","title":"Max MSP","text":"<ul> <li><code>mrp.osc</code> object &amp; helpfile</li> </ul>"},{"location":"#python","title":"Python","text":"<p>The <code>mrp</code> Python package lives in our iil-python-tools repo: http://github.com/Intelligent-Instruments-Lab/iil-python-tools. Follow the instructions there to install it, then read/try the examples in this repo.</p>"},{"location":"#install","title":"Install","text":"<p><code>iimrp</code> can be installed via PyPI:</p> <pre><code>pip install iimrp\n</code></pre>"},{"location":"#develop","title":"Develop","text":"<pre><code>git clone git@github.com:Intelligent-Instruments-Lab/iimrp.git\npip install -e iimrp\n</code></pre>"},{"location":"#contact","title":"Contact","text":"<p><code>iimrp</code> is developed by the Intelligent Instruments Lab. Get in touch to collaborate:</p> <p>\u25e6 iil.is \u25e6  Facebook \u25e6  Instagram \u25e6  X (Twitter) \u25e6  YouTube \u25e6  Discord \u25e6  GitHub \u25e6  LinkedIn \u25e6  Email \u25e6 </p>"},{"location":"#funding","title":"Funding","text":"<p>The Intelligent Instruments project (INTENT) is funded by the European Research Council (ERC) under the European Union\u2019s Horizon 2020 research and innovation programme (Grant agreement No. 101001848).</p>"},{"location":"osc/","title":"OSC","text":"<p>Important: all paths are prefixed with <code>/mrp</code>, everything else is ignored</p>"},{"location":"osc/#ip-address-and-ports","title":"IP address and ports","text":"<ul> <li>Default port: <code>7770</code></li> <li>Default IP: <code>[localhost](http://localhost)</code> / <code>127.0.0.1</code></li> <li>These can presumably be set using command line arguments to <code>./mrp</code>. Type <code>./mrp -h</code> or <code>./mrp --help</code> for a full list of options.</li> </ul>"},{"location":"osc/#alphabetical-paths-index","title":"Alphabetical paths index","text":"<pre><code>/midi: byte a, byte b, byte c // standard 3-byte MIDI messages e.g. 144 90 60\n/pedal/damper: int value || float value // change damper value\n/pedal/sostenuto: int value || float value // change sostenuto value\n/ptrk/mute: [array int notes]\n/ptrk/pitch: float freq, float amp\n/quality/brightness: int midiChannel, int midiNote, float brightness // brightness is an independent map to harmonic content, reduced to a linear scale\n/quality/intensity: int midiChannel, int midiNote, float intensity // intensity is a map to amplitude and harmonic content, relative to the current intensity\n/quality/pitch: int midiChannel, int midiNote, float pitch // Frequency base is relative to the fundamental frequency of the MIDI note\n/quality/pitch/vibrato: int midiChannel, int midiNote, float pitch // Frequency vibrato is a periodic modulation in frequency, zero-centered (+/-1 maps to range loaded from XML)\n/quality/harmonic: int midiChannel, int midiNote, float harmonic // ?\n/quality/harmonics/raw: int midiChannel, int midiNote, [array of float harmonics] // ?\n/ui/allnotesoff // turn all current notes off\n/ui/cal/save // Marked as LEGACY\n/ui/cal/load // Marked as LEGACY\n/ui/cal/phase: float p \n/ui/cal/volume: float v\n/ui/cal/currentnote: int n // \"Send a message announcing the current note, to update the UI\"\n/ui/gate // Marked as LEGACY\n/ui/harmonic // Marked as LEGACY\n/ui/patch/up // increment current program\n/ui/patch/down // decrement current program\n/ui/patch/set: int p // 0-N, set the current program to the given parameter\n/ui/pianokey/calibrate/start\n/ui/pianokey/calibrate/finish\n/ui/pianokey/calibrate/abort\n/ui/pianokey/calibrate/idle: // (?)\n/ui/pianokey/calibrate/disable: [array int keys] // 0-127, disable specified keys\n/ui/pianokey/calibrate/save: // only saves to `mrp-pb-calibration.txt`\n/ui/pianokey/calibrate/load: // only loads from `mrp-pb-calibration.txt`\n/ui/pianokey/calibrate/clear\n/ui/status/keyboard: // get real-time calibration status (?)\n/ui/tuning/global // Marked as LEGACY\n/ui/tuning/stretch // Marked as LEGACY\n/ui/volume: float vol // 0-1, &gt;0.5 ? 4^((vol-0.5)/0.5) : 10^((vol-0.5)/0.5)\n/ui/volume/raw: float vol // 0-1, set volume directly\n</code></pre>"},{"location":"osc/#paths-by-topic-source-file-with-notes","title":"Paths by topic &amp; source file, with notes","text":""},{"location":"osc/#midi-midi-notes","title":"<code>/midi</code>: MIDI notes","text":"<ul> <li><code>osccontroller.cpp</code> <code>OscController::handler</code>:</li> </ul> <pre><code>/midi: byte a, byte b, byte c // standard 3-byte MIDI messages e.g. 144 90 60\n</code></pre>"},{"location":"osc/#midi-over-osc-emulation","title":"MIDI Over OSC Emulation","text":"<ul> <li> <p><code>./mrp/source/main.cpp</code></p> <ul> <li>L493: <code>MidiController* mainMidiController = new MidiController(mainRender);</code></li> <li>L512: <code>useOscMidi = true</code> by default</li> <li> <p>L612: can also be turned off via CLI input while running</p> <pre><code>case 'z':\n  useOsc = false;\n    useOscMidi = false;\n</code></pre> </li> <li> <p>L1091: OscController has a reference to the main MIDI controller and OscMIDI is on</p> <pre><code>oscController-&gt;setMidiController(mainMidiController); // Pass a reference to the MIDI controller\noscController-&gt;setUseOscMidi(useOscMidi);\n</code></pre> </li> </ul> </li> <li> <p>OscController</p> <ul> <li><code>./mrp/source/osccontroller.h</code><ul> <li>L62: <code>void setUseOscMidi(bool use) { useOscMidi_ = use; }</code></li> <li>L124: <code>bool useOscMidi_; // Whether we use OSC MIDI emulation</code></li> </ul> </li> <li> <p><code>./mrp/source/osccontroller.cpp</code></p> <ul> <li> <p>L72: <code>if (useOscMidi_) // OSC MIDI emulation</code> followed by a list of OSC paths:</p> <pre><code>/mrp/midi\n/mrp/quality/brightness\n/mrp/quality/intensity\n/mrp/quality/pitch\n/mrp/quality/pitch/vibrato\n/mrp/quality/harmonic\n/mrp/quality/harmonics/raw\n/mrp/volume\n/mrp/allnotesoff\n</code></pre> </li> <li> <p>L75: <code>/mrp/midi</code> sends off OSC message for parsing</p> <pre><code>if (!strcmp(path, \"/mrp/midi\") &amp;&amp; argc &gt;= 1) {\n  if (types[0] == 'm')\n    return handleMidi(argv[0]-&gt;m[1], argv[0]-&gt;m[2], argv[0]-&gt;m[3]);\n</code></pre> </li> <li> <p>L293: <code>OscController::handleMidi</code></p> <pre><code>// Handle a MIDI message encapsulated by OSC.  This will be a standard 3-byte\n// message, and should be passed to the MIDI controller as if it originated from\n// a real MIDI device. Returns 0 on success (packet handled).\n\nint OscController::handleMidi(unsigned char byte1, unsigned char byte2, unsigned char byte3) {\n    vector&lt;unsigned char&gt; midiMsg;\n\n    if (midiController_ == NULL)\n        return 1;\n\n    midiMsg.push_back(byte1);\n    midiMsg.push_back(byte2);\n    midiMsg.push_back(byte3);\n\n    // FIXME: deltaTime\n    midiController_-&gt;rtMidiCallback(0.0, &amp;midiMsg, OSC_MIDI_CONTROLLER_NUM);\n\n    return 0;\n}\n</code></pre> </li> </ul> </li> </ul> </li> <li> <p>MidiController</p> <ul> <li> <p><code>./mrp/source/midicontroller.cpp</code></p> <ul> <li> <p>L964 <code>MidiController::rtMidiCallback</code></p> <pre><code>// This gets called every time MIDI data becomes available on any input\n// controller.  deltaTime gives us the time since the last event on the same\n// controller, message holds a 3-byte MIDI message, and inputNumber tells us the\n// number of the device that triggered it (see main.cpp for how this number is\n// calculated).\n\n// For now, we don't store separate state for separate devices: we use standard\n// MIDI channels instead. channel 0 is the main (piano) keyboard, channel 1 the\n// first auxiliary keyboard, and so on.\n\nvoid MidiController::rtMidiCallback(double deltaTime, vector&lt;unsigned char&gt;* message, int inputNumber) {\n...\n</code></pre> </li> </ul> </li> <li> <p><code>./mrp/source/midicontroller.h</code></p> <ul> <li> <p>L74 various MIDI commands which match up with same in <code>./mrp/source/scanner_midi.h</code></p> <pre><code>enum { // MIDI messages\n    MESSAGE_NOTEOFF = 0x80,\n    MESSAGE_NOTEON = 0x90,\n    MESSAGE_AFTERTOUCH_POLY = 0xA0,\n    MESSAGE_CONTROL_CHANGE = 0xB0,\n    MESSAGE_PROGRAM_CHANGE = 0xC0,\n    MESSAGE_AFTERTOUCH_CHANNEL = 0xD0,\n    MESSAGE_PITCHWHEEL = 0xE0,\n    MESSAGE_SYSEX = 0xF0,\n    MESSAGE_SYSEX_END = 0xF7,\n    MESSAGE_ACTIVE_SENSE = 0xFE,\n    MESSAGE_RESET = 0xFF\n};\n\nenum { // Partial listing of MIDI controllers\n    CONTROL_BANK_SELECT = 0,\n    CONTROL_MODULATION_WHEEL = 1,\n    CONTROL_VOLUME = 7,\n    CONTROL_PATCH_CHANGER = 14, // Piano bar patch-changing interface (deprecate this?)\n    CONTROL_AUX_PEDAL = 15, // Use this as an auxiliary pedal\n    CONTROL_MRP_BASE = 16, // Base of a range of controllers used by MRP signal\n                           // routing hardware\n    CONTROL_BANK_SELECT_LSB = 32,\n    CONTROL_MODULATION_WHEEL_LSB = 33,\n    CONTROL_VOLUME_LSB = 39,\n    CONTROL_DAMPER_PEDAL = 64,\n    CONTROL_SOSTENUTO_PEDAL = 66,\n    CONTROL_SOFT_PEDAL = 67,\n    CONTROL_ALL_SOUND_OFF = 120,\n    CONTROL_ALL_CONTROLLERS_OFF = 121,\n    CONTROL_LOCAL_KEYBOARD = 122,\n    CONTROL_ALL_NOTES_OFF = 123,\n    CONTROL_OMNI_OFF = 124,\n    CONTROL_OMNI_ON = 125,\n    CONTROL_MONO_OPERATION = 126,\n    CONTROL_POLY_OPERATION = 127\n};\n\nenum { // Piano damper states (excluding effect of damper pedal)\n    DAMPER_DOWN = 0, // Not lifted\n    DAMPER_KEY = 1, // Lifted by key\n    DAMPER_SOSTENUTO = 2 // Held by sostenuto pedal\n                         // Key and Sostenuto: 3\n};\n</code></pre> </li> </ul> </li> </ul> </li> </ul>"},{"location":"osc/#quality-real-time-note-timbre-parameters","title":"<code>/quality</code>: real-time note timbre parameters","text":"<ul> <li><code>osccontroller.cpp</code> <code>OscController::handler</code>:</li> </ul> <pre><code>/quality/brightness: int midiChannel, int midiNote, float brightness // brightness is an independent map to harmonic content, reduced to a linear scale\n/quality/intensity: int midiChannel, int midiNote, float intensity // intensity is a map to amplitude and harmonic content, relative to the current intensity\n/quality/pitch: int midiChannel, int midiNote, float pitch // Frequency base is relative to the fundamental frequency of the MIDI note\n/quality/pitch/vibrato: int midiChannel, int midiNote, float pitch // Frequency vibrato is a periodic modulation in frequency, zero-centered (+/-1 maps to range loaded from XML)\n/quality/harmonic: int midiChannel, int midiNote, float harmonic // ?\n/quality/harmonics/raw: int midiChannel, int midiNote, [array of float harmonics] // ?\n</code></pre>"},{"location":"osc/#ui-various-interfaces","title":"<code>/ui</code>: various interfaces","text":"<ul> <li>Interfaces for KeyScanner calibration, patch navigation, tuning and volume settings, etc</li> <li> <p><code>pianobar.cpp</code> <code>ContinuousKeyController::setOscController</code>:</p> <pre><code>/ui/pianokey/calibrate/start\n/ui/pianokey/calibrate/finish\n/ui/pianokey/calibrate/abort\n/ui/pianokey/calibrate/idle: // (?)\n/ui/pianokey/calibrate/disable: [array int keys] // 0-127, disable specified keys\n/ui/pianokey/calibrate/save: // only saves to `mrp-pb-calibration.txt`\n/ui/pianokey/calibrate/load: // only loads from `mrp-pb-calibration.txt`\n/ui/pianokey/calibrate/clear\n/ui/status/keyboard: // get real-time calibration status (?)\n</code></pre> </li> <li> <p><code>midicontroller.cpp</code> <code>MidiController::setOscController</code>:</p> <pre><code>/ui/patch/up // increment current program\n/ui/patch/down // decrement current program\n/ui/patch/set: int p // 0-N, set the current program to the given parameter\n/ui/allnotesoff // turn all current notes off\n/ui/cal/save // Marked as LEGACY\n/ui/cal/load // Marked as LEGACY\n/ui/harmonic // Marked as LEGACY\n/ui/gate // Marked as LEGACY\n/ui/tuning/global // Marked as LEGACY\n/ui/tuning/stretch // Marked as LEGACY\n</code></pre> </li> <li> <p><code>audiorender.cpp</code> <code>AudioRender::setOscController</code>:</p> <pre><code>/ui/volume: float vol // 0-1, &gt;0.5 ? 4^((vol-0.5)/0.5) : 10^((vol-0.5)/0.5)\n/ui/volume/raw: float vol // 0-1, set volume directly\n</code></pre> </li> <li> <p><code>note.cpp</code> <code>CalibratorNote::setOscController</code>:</p> <p>This class implements a calibration note. The differences from MidiNote are:</p> <p>(1) It is monophonic: a new note coming in of this type will stop the old one</p> <p>(2) It listens to a pair of MIDI controllers to change the phase offset and amplitude of the current note </p> <p>(3) It can write these values to a special XML file that is loaded on startup </p> <p>(4) It does not need any Synth parameters; one internal synth is loaded automatically </p> <pre><code>/ui/cal/phase: float p \n/ui/cal/volume: float v\n/ui/cal/currentnote: int n // \"Send a message announcing the current note, to update the UI\"\n</code></pre> </li> </ul>"},{"location":"osc/#pedal-midi-expression-pedal","title":"<code>/pedal</code>: MIDI expression pedal","text":"<ul> <li> <p><code>midicontroller.cpp</code> <code>MidiController::setOscController</code>:</p> <pre><code>/pedal/damper: int value || float value // change damper value\n/pedal/sostenuto: int value || float value // change sostenuto value\n</code></pre> </li> </ul>"},{"location":"osc/#ptrk-pitch-tracking-for-pll-synth","title":"<code>/ptrk</code>: pitch-tracking for PLL Synth","text":"<ul> <li> <p><code>pitchtrack.cpp</code> <code>PitchTrackController::setOscController</code></p> <p>This class handles all the central dispatching related to tracking an incoming pitch.  Note that the actual tracking takes place externally, with the messages arriving via OSC.  The functions performed by this class include:</p> <ul> <li>Parsing pieces of the XML patch table related to pitch-tracking</li> <li>Allocating new notes and releasing old ones</li> <li>Routing incoming pitch and amplitude messages to the appropriate notes</li> </ul> <pre><code>/ptrk/pitch: float freq, float amp\n/ptrk/mute: [array int notes]\n</code></pre> </li> </ul>"},{"location":"osc/#misc","title":"misc","text":"<ul> <li> <p><code>osccontroller.cpp</code> <code>OscController::handler</code>:</p> <pre><code>/volume: float volume // set global amplitude of audio engine\n/allnotesoff // turn off all notes\n</code></pre> </li> </ul>"},{"location":"reference/iimrp/__init__/","title":"init","text":""},{"location":"reference/iimrp/harmonics/","title":"Harmonics","text":"<p>Functions for calculating harmonics and harmonic series suitable for interfacing with the MRP.</p> <p>TODO: Calculate f0 pitch-bend to go from harmonic to frequency (review MRP API) TODO: nearest harmonics: for a given frequency and a set of notes, find nearest multiples of f0</p>"},{"location":"reference/iimrp/harmonics/#iimrp.harmonics.alternating_sign_harmonic_series","title":"<code>alternating_sign_harmonic_series(n)</code>","text":"<p>Generate the alternating sign harmonic series.</p> <p>Arguments: n -- length of the harmonic series</p> Source code in <code>src/iimrp/harmonics.py</code> <pre><code>def alternating_sign_harmonic_series(n):\n    \"\"\"\n    Generate the alternating sign harmonic series.\n\n    Arguments:\n    n -- length of the harmonic series\n    \"\"\"  \n    return np.array([((-1)**i) / (i + 1) for i in range(n)])\n</code></pre>"},{"location":"reference/iimrp/harmonics/#iimrp.harmonics.basic_harmonic_series","title":"<code>basic_harmonic_series(n)</code>","text":"<p>Generate the simple harmonic series.</p> <p>Arguments: n -- length of the harmonic series</p> Source code in <code>src/iimrp/harmonics.py</code> <pre><code>def basic_harmonic_series(n):\n    \"\"\"\n    Generate the simple harmonic series.\n\n    Arguments:\n    n -- length of the harmonic series\n    \"\"\"  \n    return np.array([1 / (i + 1) for i in range(n)])\n</code></pre>"},{"location":"reference/iimrp/harmonics/#iimrp.harmonics.const_base_harmonic_series","title":"<code>const_base_harmonic_series(n, base=5)</code>","text":"<p>Generate the harmonic series with a constant base, where each denominator is base*i + 1.</p> <p>Arguments: n -- length of the harmonic series base -- base for the harmonic series (default 5)</p> Source code in <code>src/iimrp/harmonics.py</code> <pre><code>def const_base_harmonic_series(n, base=5):\n    \"\"\"\n    Generate the harmonic series with a constant base, where each denominator is base*i + 1.\n\n    Arguments:\n    n -- length of the harmonic series\n    base -- base for the harmonic series (default 5)\n    \"\"\"  \n    return np.array([1 / (base*i + 1) for i in range(n)])\n</code></pre>"},{"location":"reference/iimrp/harmonics/#iimrp.harmonics.create_frequency_map","title":"<code>create_frequency_map(base_frequency, harmonic_generator, n, **kwargs)</code>","text":"<p>Given a base frequency, a harmonic series generator function, and a number of harmonics, returns a map of frequencies to amplitudes.</p> <p>Arguments: base_frequency -- the base frequency from which to calculate harmonics harmonic_generator -- function that generates the amplitudes of a harmonic series n -- the number of harmonics to calculate kwargs -- additional keyword arguments to pass to the harmonic_generator function</p> Source code in <code>src/iimrp/harmonics.py</code> <pre><code>def create_frequency_map(base_frequency, harmonic_generator, n, **kwargs):\n    \"\"\"\n    Given a base frequency, a harmonic series generator function, and a number of harmonics,\n    returns a map of frequencies to amplitudes.\n\n    Arguments:\n    base_frequency -- the base frequency from which to calculate harmonics\n    harmonic_generator -- function that generates the amplitudes of a harmonic series\n    n -- the number of harmonics to calculate\n    kwargs -- additional keyword arguments to pass to the harmonic_generator function\n    \"\"\"\n    # Calculate the frequencies using the harmonic_frequencies function\n    frequencies = harmonic_frequencies(base_frequency, n)\n\n    # Generate the amplitudes using the harmonic generator function\n    amplitudes = harmonic_generator(n, **kwargs)\n\n    # Create a map of frequencies to amplitudes\n    frequency_map = dict(zip(frequencies, amplitudes))\n\n    return frequency_map\n</code></pre>"},{"location":"reference/iimrp/harmonics/#iimrp.harmonics.create_harmonics","title":"<code>create_harmonics(H, N=88, A0_freq=27.5)</code>","text":"<p>Create a 2D array of harmonics for a piano with N keys.</p> <p>Parameters:</p> Name Type Description Default <code>H</code> <code>int</code> <p>Number of harmonics to create.</p> required <code>N</code> <code>int</code> <p>Number of piano notes (default=88).</p> <code>88</code> <code>A0_freq</code> <code>float</code> <p>Frequency of note A0 (default=27.5).</p> <code>27.5</code> <p>Returns:</p> Type Description <code>array</code> <p>np.array: 2D array of harmonics.</p> Source code in <code>src/iimrp/harmonics.py</code> <pre><code>def create_harmonics(H:int, N:int=88, A0_freq:float=27.5) -&gt; np.array:\n    \"\"\"Create a 2D array of harmonics for a piano with N keys.\n\n    Args:\n        H (int): Number of harmonics to create.\n        N (int): Number of piano notes (default=88).\n        A0_freq (float): Frequency of note A0 (default=27.5).\n\n    Returns:\n        np.array: 2D array of harmonics.\n    \"\"\"\n    # The ratio between the frequencies of two adjacent notes in a chromatic scale\n    chromatic_ratio = 2 ** (1 / 12)\n    note_indices = np.arange(N) # Create an array of note indices\n    note_frequencies = A0_freq * (chromatic_ratio ** note_indices) # Calculate the frequencies of the notes\n    harmonic_indices = np.arange(1, H + 1) # Create an array of harmonic indices\n    harmonics = note_frequencies[:, np.newaxis] * harmonic_indices # Calculate the frequencies of the harmonics\n    return harmonics\n</code></pre>"},{"location":"reference/iimrp/harmonics/#iimrp.harmonics.create_single_harmonic_gain_array","title":"<code>create_single_harmonic_gain_array(index, gain=1.0, N=MAX_HARMONICS)</code>","text":"<p>Create an array of harmonic gains with a single non-zero value.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index of the harmonic to set.</p> required <code>gain</code> <code>float</code> <p>Gain of the harmonic. Defaults to 1.0.</p> <code>1.0</code> <code>N</code> <code>int</code> <p>Length of the array. Defaults to MAX_HARMONICS.</p> <code>MAX_HARMONICS</code> <p>Returns:</p> Type Description <code>array</code> <p>np.array: Array of harmonic gains.</p> Source code in <code>src/iimrp/harmonics.py</code> <pre><code>def create_single_harmonic_gain_array(index:int, gain:float=1.0, N:int=MAX_HARMONICS) -&gt; np.array:\n    \"\"\"Create an array of harmonic gains with a single non-zero value.\n\n    Args:\n        index (int): Index of the harmonic to set.\n        gain (float, optional): Gain of the harmonic. Defaults to 1.0.\n        N (int, optional): Length of the array. Defaults to MAX_HARMONICS.\n\n    Returns:\n        np.array: Array of harmonic gains.\n    \"\"\"\n    harmonics = np.zeros(N) # Create an array of zeros with length N\n    # Set the value at the harmonic index to the gain\n    harmonics[index - 1] = gain  # Subtract 1 because numpy arrays are 0-indexed\n    return harmonics\n</code></pre>"},{"location":"reference/iimrp/harmonics/#iimrp.harmonics.create_subplot","title":"<code>create_subplot(func, n)</code>","text":"<p>Given a harmonic generating function and length, returns a subplot titled by function name.</p> <p>Arguments: func -- function that generates a harmonic series n -- length of the harmonic series</p> Source code in <code>src/iimrp/harmonics.py</code> <pre><code>def create_subplot(func, n):\n    \"\"\"\n    Given a harmonic generating function and length, returns a subplot titled by function name.\n\n    Arguments:\n    func -- function that generates a harmonic series\n    n -- length of the harmonic series\n    \"\"\"\n    # Generate harmonic series\n    harmonic_series = func(n)\n\n    # Arrange function name into title\n    title = ' '.join(func.__name__.split('_')).title() + ' (' + str(n) + ')'\n\n    # Create a new plot with a axis labels and no grid/axis\n    p = figure(width=300, height=300, title=title, x_axis_label='Harmonics', y_axis_label='Value', toolbar_location=None)\n    p.xgrid.grid_line_color = None\n    p.ygrid.grid_line_color = None\n\n    # Add a bar renderer\n    p.vbar(x=list(range(n)), top=harmonic_series, width=0.5)\n\n    return p\n</code></pre>"},{"location":"reference/iimrp/harmonics/#iimrp.harmonics.cubic_harmonic_series","title":"<code>cubic_harmonic_series(n)</code>","text":"<p>Generate the harmonic series where denominators are cubes of integers from 0 to n-1.</p> <p>Arguments: n -- limiting value for the series</p> Source code in <code>src/iimrp/harmonics.py</code> <pre><code>def cubic_harmonic_series(n):\n    \"\"\"\n    Generate the harmonic series where denominators are cubes of integers from 0 to n-1.\n\n    Arguments:\n    n -- limiting value for the series\n    \"\"\"  \n    return np.array([1 / (i**3 + 1) for i in range(n)])\n</code></pre>"},{"location":"reference/iimrp/harmonics/#iimrp.harmonics.double_harmonic_series","title":"<code>double_harmonic_series(n)</code>","text":"<p>Generate the double harmonic series which includes fractional terms for both i and i+1 index.</p> <p>Arguments: n -- length of the harmonic series</p> Source code in <code>src/iimrp/harmonics.py</code> <pre><code>def double_harmonic_series(n):\n    \"\"\"\n    Generate the double harmonic series which includes fractional terms for both i and i+1 index.\n\n    Arguments:\n    n -- length of the harmonic series\n    \"\"\"\n    return np.array([1/(2*i+1) + 1/(2*(i+1)) for i in range(n)])\n</code></pre>"},{"location":"reference/iimrp/harmonics/#iimrp.harmonics.even_harmonic_series","title":"<code>even_harmonic_series(n)</code>","text":"<p>Generate the harmonic series that only includes even denominators.</p> <p>Arguments: n -- length of the harmonic series</p> Source code in <code>src/iimrp/harmonics.py</code> <pre><code>def even_harmonic_series(n):\n    \"\"\"\n    Generate the harmonic series that only includes even denominators.\n\n    Arguments:\n    n -- length of the harmonic series\n    \"\"\"  \n    return np.array([1 / (2*(i + 1)) for i in range(n)])\n</code></pre>"},{"location":"reference/iimrp/harmonics/#iimrp.harmonics.exponent_harmonic_series","title":"<code>exponent_harmonic_series(n, base=0.5)</code>","text":"<p>Generate the harmonic series where each denominator is raised to an exponential function of index.</p> <p>Arguments: n -- length of the harmonic series base -- base of the exponent (default 0.5)</p> Source code in <code>src/iimrp/harmonics.py</code> <pre><code>def exponent_harmonic_series(n, base=0.5):\n    \"\"\"\n    Generate the harmonic series where each denominator is raised to an exponential function of index.\n\n    Arguments:\n    n -- length of the harmonic series\n    base -- base of the exponent (default 0.5)\n    \"\"\"\n    return np.array([1 / np.power(base, i) for i in range(n)])\n</code></pre>"},{"location":"reference/iimrp/harmonics/#iimrp.harmonics.factorial_harmonic_series","title":"<code>factorial_harmonic_series(n)</code>","text":"<p>Generate the harmonic series where each denominator is factorial of index.</p> <p>Arguments: n -- limiting value for factorial calculation and length of the series</p> Source code in <code>src/iimrp/harmonics.py</code> <pre><code>def factorial_harmonic_series(n):\n    \"\"\"\n    Generate the harmonic series where each denominator is factorial of index.\n\n    Arguments:\n    n -- limiting value for factorial calculation and length of the series\n    \"\"\"  \n    return np.array([1 / np.math.factorial(i) for i in range(n)])\n</code></pre>"},{"location":"reference/iimrp/harmonics/#iimrp.harmonics.fibonacci_harmonic_series","title":"<code>fibonacci_harmonic_series(n)</code>","text":"<p>Generate the harmonic series where denominators are fibonacci numbers.</p> <p>Arguments: n -- limiting term for the fibonacci series and length of the harmonic series</p> Source code in <code>src/iimrp/harmonics.py</code> <pre><code>def fibonacci_harmonic_series(n):\n    \"\"\"\n    Generate the harmonic series where denominators are fibonacci numbers.\n\n    Arguments:\n    n -- limiting term for the fibonacci series and length of the harmonic series \n    \"\"\"  \n    fibonacci_numbers = np.array([0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987][:n])\n    return 1 / fibonacci_numbers[2:]\n</code></pre>"},{"location":"reference/iimrp/harmonics/#iimrp.harmonics.fibonacci_square_series","title":"<code>fibonacci_square_series(n)</code>","text":"<p>Generate the harmonic series where denominators are squares of fibonacci numbers.</p> <p>Arguments: n -- limiting term for the fibonacci series and length of the harmonic series</p> Source code in <code>src/iimrp/harmonics.py</code> <pre><code>def fibonacci_square_series(n):\n    \"\"\"\n    Generate the harmonic series where denominators are squares of fibonacci numbers.\n\n    Arguments:\n    n -- limiting term for the fibonacci series and length of the harmonic series \n    \"\"\"  \n    fibonacci_numbers = np.array([0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987][:n])\n    return 1 / np.power(fibonacci_numbers[2:], 2)\n</code></pre>"},{"location":"reference/iimrp/harmonics/#iimrp.harmonics.find_harmonic","title":"<code>find_harmonic(frequency, A0_note=21)</code>","text":"<p>Find the nearest harmonic for a given frequency.</p> <p>Parameters:</p> Name Type Description Default <code>frequency</code> <code>float</code> <p>Frequency to find the nearest harmonic for.</p> required <code>A0_note</code> <code>int</code> <p>MIDI note number for A0. Defaults to 21.</p> <code>21</code> <p>Returns:</p> Type Description <code>array</code> <p>np.array: Array containing the MIDI note number, harmonic index, and frequency of the nearest harmonic.</p> Source code in <code>src/iimrp/harmonics.py</code> <pre><code>def find_harmonic(frequency:float, A0_note:int=21) -&gt; np.array:\n    \"\"\"Find the nearest harmonic for a given frequency.\n\n    Args:\n        frequency (float): Frequency to find the nearest harmonic for.\n        A0_note (int, optional): MIDI note number for A0. Defaults to 21.\n\n    Returns:\n        np.array: Array containing the MIDI note number, harmonic index, and frequency of the nearest harmonic.\n    \"\"\"\n    harmonics = piano_harmonics # Get the global 2D array of harmonics\n    # Calculate the absolute differences between the harmonics and the input frequency\n    differences = np.abs(harmonics - frequency)\n    # Find the index of the minimum difference\n    note_index, harmonic_index = np.unravel_index(np.argmin(differences), differences.shape)\n    # Convert the note index to a MIDI note number and the harmonic index to a 1-based index\n    midi_note_number = note_index + A0_note # MIDI note number for A0 is 21\n    nearest_harmonic = harmonics[note_index, harmonic_index] # Get the nearest harmonic\n    return np.array([midi_note_number, harmonic_index + 1, nearest_harmonic])\n</code></pre>"},{"location":"reference/iimrp/harmonics/#iimrp.harmonics.find_nearest_harmonics","title":"<code>find_nearest_harmonics(frequency, H, sort='frequency')</code>","text":"<p>Find the H nearest harmonics for a given frequency.</p> <p>Parameters:</p> Name Type Description Default <code>frequency</code> <code>float</code> <p>Frequency to find the nearest harmonics for.</p> required <code>H</code> <code>int</code> <p>Number of harmonics to find.</p> required <code>sort</code> <code>str</code> <p>Sort the results by \"note\", \"harmonic\", or \"frequency\". Defaults to \"frequency\".</p> <code>'frequency'</code> <p>Returns:</p> Type Description <code>array</code> <p>np.array: Array containing the MIDI note number, harmonic index, and frequency of the nearest harmonics.</p> Source code in <code>src/iimrp/harmonics.py</code> <pre><code>def find_nearest_harmonics(frequency:float, H:int, sort:str=\"frequency\") -&gt; np.array:\n    \"\"\"Find the H nearest harmonics for a given frequency.\n\n    Args:\n        frequency (float): Frequency to find the nearest harmonics for.\n        H (int): Number of harmonics to find.\n        sort (str, optional): Sort the results by \"note\", \"harmonic\", or \"frequency\". Defaults to \"frequency\".\n\n    Returns:\n        np.array: Array containing the MIDI note number, harmonic index, and frequency of the nearest harmonics.\n    \"\"\"\n    harmonics = piano_harmonics # Get the global 2D array of harmonics\n    # Calculate the absolute differences between the harmonics and the input frequency\n    differences = np.abs(harmonics - frequency)\n    # Get the indices of the H smallest differences\n    indices = np.argpartition(differences, H, axis=None)[:H]\n    # Convert the indices to 2D indices\n    note_indices, harmonic_indices = np.unravel_index(indices, differences.shape)\n    # Convert the note indices to MIDI note numbers\n    midi_note_numbers = note_indices + 21  # MIDI note number for A0 is 21\n    # Create a 2D array of the results\n    results = np.column_stack((midi_note_numbers, harmonic_indices + 1, harmonics[note_indices, harmonic_indices]))\n    # Sort the results\n    sort_index = {\"note\": 0, \"harmonic\": 1, \"frequency\": 2}.get(sort, 2)\n    results = results[results[:, sort_index].argsort()]\n    return results\n</code></pre>"},{"location":"reference/iimrp/harmonics/#iimrp.harmonics.freq_to_harmonics_and_gains","title":"<code>freq_to_harmonics_and_gains(frequency, H, N=MAX_HARMONICS, gain=1.0, sort='frequency')</code>","text":"<p>Convert a frequency to an array of nearest harmonics and an array of harmonic gain arrays.</p> <p>Parameters:</p> Name Type Description Default <code>frequency</code> <code>float</code> <p>Frequency to convert.</p> required <code>H</code> <code>int</code> <p>Number of harmonics to find.</p> required <code>N</code> <code>int</code> <p>Length of the harmonic gain arrays. Defaults to MAX_HARMONICS.</p> <code>MAX_HARMONICS</code> <code>gain</code> <code>float</code> <p>Gain of the harmonics. Defaults to 1.0.</p> <code>1.0</code> <code>sort</code> <code>str</code> <p>Sort the results by \"note\", \"harmonic\", or \"frequency\". Defaults to \"frequency\".</p> <code>'frequency'</code> <p>Returns:</p> Type Description <code>tuple[ndarray, ndarray]</code> <p>tuple[np.ndarray, np.ndarray]: Array of nearest harmonics and array of harmonic gain arrays.</p> Source code in <code>src/iimrp/harmonics.py</code> <pre><code>def freq_to_harmonics_and_gains(frequency:float, H:int, N:int=MAX_HARMONICS, gain:float=1.0, sort:str=\"frequency\") -&gt; tuple[np.ndarray, np.ndarray]:\n    \"\"\"Convert a frequency to an array of nearest harmonics and an array of harmonic gain arrays.\n\n    Args:\n        frequency (float): Frequency to convert.\n        H (int): Number of harmonics to find.\n        N (int, optional): Length of the harmonic gain arrays. Defaults to MAX_HARMONICS.\n        gain (float, optional): Gain of the harmonics. Defaults to 1.0.\n        sort (str, optional): Sort the results by \"note\", \"harmonic\", or \"frequency\". Defaults to \"frequency\".\n\n    Returns:\n        tuple[np.ndarray, np.ndarray]: Array of nearest harmonics and array of harmonic gain arrays.\n    \"\"\"\n    # Find the nearest harmonics\n    nearest_harmonics = find_nearest_harmonics(frequency, H, sort)\n    # Get the harmonic gain arrays\n    harmonic_gain_arrays = get_harmonic_gain_arrays(nearest_harmonics, gain, N)\n    return (nearest_harmonics, harmonic_gain_arrays)\n</code></pre>"},{"location":"reference/iimrp/harmonics/#iimrp.harmonics.freq_to_midi","title":"<code>freq_to_midi(frequency)</code>","text":"<p>Converts a frequency in Hz to a MIDI note number.</p> <p>Arguments:  frequency -- frequency in Hz</p> Source code in <code>src/iimrp/harmonics.py</code> <pre><code>def freq_to_midi(frequency):\n    \"\"\"\n    Converts a frequency in Hz to a MIDI note number.\n\n    Arguments: \n    frequency -- frequency in Hz\n    \"\"\"\n    return int(round(69 + 12 * np.log2(frequency / 440.0)))\n</code></pre>"},{"location":"reference/iimrp/harmonics/#iimrp.harmonics.geometric_progression_harmonic_series","title":"<code>geometric_progression_harmonic_series(n, base=2)</code>","text":"<p>Generate the harmonic series where each denominator is geometric progression.</p> <p>Arguments: n -- limiting value for geometric progression and length of the series base -- base of the geometric progression (default 2)</p> Source code in <code>src/iimrp/harmonics.py</code> <pre><code>def geometric_progression_harmonic_series(n, base=2):\n    \"\"\"\n    Generate the harmonic series where each denominator is geometric progression.\n\n    Arguments:\n    n -- limiting value for geometric progression and length of the series\n    base -- base of the geometric progression (default 2)\n    \"\"\"\n    return np.array([1 / (base ** i) for i in range(n)])\n</code></pre>"},{"location":"reference/iimrp/harmonics/#iimrp.harmonics.get_harmonic_gain_arrays","title":"<code>get_harmonic_gain_arrays(nearest_harmonics, gain=1.0, N=MAX_HARMONICS)</code>","text":"<p>Get an array of harmonic gain arrays for a given array of nearest harmonics.</p> <p>Parameters:</p> Name Type Description Default <code>nearest_harmonics</code> <code>ndarray</code> <p>Array of nearest harmonics.</p> required <code>gain</code> <code>float</code> <p>Gain of the harmonics. Defaults to 1.0.</p> <code>1.0</code> <code>N</code> <code>int</code> <p>Length of the harmonic gain arrays. Defaults to MAX_HARMONICS.</p> <code>MAX_HARMONICS</code> <p>Returns:</p> Type Description <code>array</code> <p>np.array: Array of harmonic gain arrays.</p> Source code in <code>src/iimrp/harmonics.py</code> <pre><code>def get_harmonic_gain_arrays(nearest_harmonics:np.ndarray, gain:float=1.0, N:int=MAX_HARMONICS) -&gt; np.array:\n    \"\"\"Get an array of harmonic gain arrays for a given array of nearest harmonics.\n\n    Args:\n        nearest_harmonics (np.ndarray): Array of nearest harmonics.\n        gain (float, optional): Gain of the harmonics. Defaults to 1.0.\n        N (int, optional): Length of the harmonic gain arrays. Defaults to MAX_HARMONICS.\n\n    Returns:\n        np.array: Array of harmonic gain arrays.\n    \"\"\"\n    harmonic_gain_arrays = [] # Initialize an empty list to store the arrays\n    # For each row in the nearest harmonics array\n    for row in nearest_harmonics:\n        harmonic_index = int(row[1]) # Get the harmonic index\n        # Create the harmonic gain array\n        harmonic_gain_array = create_single_harmonic_gain_array(harmonic_index, gain, N)\n        # Add the array to the list\n        harmonic_gain_arrays.append(harmonic_gain_array)\n    return np.array(harmonic_gain_arrays)\n</code></pre>"},{"location":"reference/iimrp/harmonics/#iimrp.harmonics.harmonic_frequencies","title":"<code>harmonic_frequencies(base_frequency, n)</code>","text":"<p>Given a base frequency and a number of harmonics, returns the frequencies of the harmonics.</p> <p>Arguments: base_frequency -- the base frequency from which to calculate harmonics n -- the number of harmonics to calculate</p> Source code in <code>src/iimrp/harmonics.py</code> <pre><code>def harmonic_frequencies(base_frequency, n):\n    \"\"\"\n    Given a base frequency and a number of harmonics, returns the frequencies of the harmonics.\n\n    Arguments:\n    base_frequency -- the base frequency from which to calculate harmonics\n    n -- the number of harmonics to calculate\n    \"\"\"\n    # Calculate the frequencies by multiplying the base frequency by each integer up to n\n    frequencies = [base_frequency * i for i in range(1, n+1)]\n\n    return frequencies\n</code></pre>"},{"location":"reference/iimrp/harmonics/#iimrp.harmonics.harmonic_map_for_frequencies","title":"<code>harmonic_map_for_frequencies(freq_list)</code>","text":"<p>Computes a harmonic map for a list of base frequencies.</p> <p>Arguments: freq_list -- List of frequencies to calculate the harmonics for.</p> Source code in <code>src/iimrp/harmonics.py</code> <pre><code>def harmonic_map_for_frequencies(freq_list):\n    \"\"\"\n    Computes a harmonic map for a list of base frequencies.\n\n    Arguments:\n    freq_list -- List of frequencies to calculate the harmonics for.\n    \"\"\"\n\n    freq_harmonic_map = {}\n\n    for base_freq in freq_list:\n        freq_harmonic_map[base_freq] = harmonic_frequencies(base_freq, 32)\n\n    return freq_harmonic_map\n</code></pre>"},{"location":"reference/iimrp/harmonics/#iimrp.harmonics.harmonic_map_for_midi_notes","title":"<code>harmonic_map_for_midi_notes(midi_list)</code>","text":"<p>Computes a harmonic map for a list of MIDI notes.</p> <p>Arguments: midi_list -- List of MIDI notes to calculate the harmonics for.</p> Source code in <code>src/iimrp/harmonics.py</code> <pre><code>def harmonic_map_for_midi_notes(midi_list):\n    \"\"\"\n    Computes a harmonic map for a list of MIDI notes.\n\n    Arguments:\n    midi_list -- List of MIDI notes to calculate the harmonics for.\n    \"\"\"\n\n    freq_harmonic_map = {}\n\n    for midi_num in midi_list:\n        base_freq = midi_to_freq(midi_num)\n        freq_harmonic_map[midi_num] = harmonic_frequencies(base_freq, 32)\n\n    return freq_harmonic_map\n</code></pre>"},{"location":"reference/iimrp/harmonics/#iimrp.harmonics.harmonic_series_with_cos","title":"<code>harmonic_series_with_cos(n)</code>","text":"<p>Generate the harmonic series where each denominator is the cosine of index.</p> <p>Arguments: n -- length of the harmonic series</p> Source code in <code>src/iimrp/harmonics.py</code> <pre><code>def harmonic_series_with_cos(n):\n    \"\"\"\n    Generate the harmonic series where each denominator is the cosine of index.\n\n    Arguments:\n    n -- length of the harmonic series\n    \"\"\"\n    return np.array([1 / np.cos(i + np.pi/2 + 1e-6) for i in range(n)])\n</code></pre>"},{"location":"reference/iimrp/harmonics/#iimrp.harmonics.harmonic_series_with_sin","title":"<code>harmonic_series_with_sin(n)</code>","text":"<p>Generate the harmonic series where each denominator is the sine of index.</p> <p>Arguments: n -- length of the harmonic series</p> Source code in <code>src/iimrp/harmonics.py</code> <pre><code>def harmonic_series_with_sin(n):\n    \"\"\"\n    Generate the harmonic series where each denominator is the sine of index.\n\n    Arguments:\n    n -- length of the harmonic series\n    \"\"\"\n    return np.array([1 / np.sin(i + np.pi/2 + 1e-6) for i in range(n)])\n</code></pre>"},{"location":"reference/iimrp/harmonics/#iimrp.harmonics.harmonic_series_with_tan","title":"<code>harmonic_series_with_tan(n)</code>","text":"<p>Generate the harmonic series where each denominator is the tangent of index.</p> <p>Arguments: n -- length of the harmonic series</p> Source code in <code>src/iimrp/harmonics.py</code> <pre><code>def harmonic_series_with_tan(n):\n    \"\"\"\n    Generate the harmonic series where each denominator is the tangent of index.\n\n    Arguments:\n    n -- length of the harmonic series\n    \"\"\"\n    return np.array([1 / np.tan(i + np.pi/4 + 1e-6) for i in range(n)])\n</code></pre>"},{"location":"reference/iimrp/harmonics/#iimrp.harmonics.logarithmic_harmonic_series","title":"<code>logarithmic_harmonic_series(n, base=2)</code>","text":"<p>Generate the harmonic series where each denominator is a logarithm of index.</p> <p>Arguments: n -- length of the series base -- base of the logarithm (default 2)</p> Source code in <code>src/iimrp/harmonics.py</code> <pre><code>def logarithmic_harmonic_series(n, base=2):\n    \"\"\"\n    Generate the harmonic series where each denominator is a logarithm of index.\n\n    Arguments:\n    n -- length of the series\n    base -- base of the logarithm (default 2)\n    \"\"\"  \n    return np.array([1 / np.log(i + base) for i in range(n)])\n</code></pre>"},{"location":"reference/iimrp/harmonics/#iimrp.harmonics.midi_to_freq","title":"<code>midi_to_freq(midi_number)</code>","text":"<p>Converts a MIDI note number into a frequency in Hz.</p> <p>Arguments:  midi_number -- MIDI note number</p> Source code in <code>src/iimrp/harmonics.py</code> <pre><code>def midi_to_freq(midi_number):\n    \"\"\"\n    Converts a MIDI note number into a frequency in Hz.\n\n    Arguments: \n    midi_number -- MIDI note number\n    \"\"\"\n    return 440.0 * 2.0**((midi_number - 69) / 12.0)\n</code></pre>"},{"location":"reference/iimrp/harmonics/#iimrp.harmonics.odd_harmonic_series","title":"<code>odd_harmonic_series(n)</code>","text":"<p>Generate the harmonic series that only includes odd denominators.</p> <p>Arguments: n -- length of the harmonic series</p> Source code in <code>src/iimrp/harmonics.py</code> <pre><code>def odd_harmonic_series(n):\n    \"\"\"\n    Generate the harmonic series that only includes odd denominators.\n\n    Arguments:\n    n -- length of the harmonic series\n    \"\"\"  \n    return np.array([1 / (2*i + 1) for i in range(n)])\n</code></pre>"},{"location":"reference/iimrp/harmonics/#iimrp.harmonics.plot_grid","title":"<code>plot_grid(functions, n)</code>","text":"<p>Given a list of harmonic series functions, plot them in a grid layout</p> <p>Arguments:  functions -- list of functions that generate harmonic series n -- length of each harmonic series</p> Source code in <code>src/iimrp/harmonics.py</code> <pre><code>def plot_grid(functions, n):\n    \"\"\"\n    Given a list of harmonic series functions, plot them in a grid layout\n\n    Arguments: \n    functions -- list of functions that generate harmonic series\n    n -- length of each harmonic series\n    \"\"\"\n    # Generate a list of subplots\n    plots = [create_subplot(func, n) for func in functions]\n\n    # Arrange the subplots in a grid layout of appropriate shape\n    grid = gridplot(plots, ncols=3)\n\n    # Output to notebook\n    output_notebook()\n\n    # Show the results\n    show(grid)\n</code></pre>"},{"location":"reference/iimrp/harmonics/#iimrp.harmonics.power_series","title":"<code>power_series(n, power=3)</code>","text":"<p>Generate the power series where each denominator is raised to a given power.</p> <p>Arguments: n -- length of the series power -- power to which each denominator is raised (default 3)</p> Source code in <code>src/iimrp/harmonics.py</code> <pre><code>def power_series(n, power=3):\n    \"\"\"\n    Generate the power series where each denominator is raised to a given power.\n\n    Arguments:\n    n -- length of the series\n    power -- power to which each denominator is raised (default 3)\n    \"\"\"  \n    return np.array([1 / (i**power + 1) for i in range(n)])\n</code></pre>"},{"location":"reference/iimrp/harmonics/#iimrp.harmonics.prime_harmonic_series","title":"<code>prime_harmonic_series(n, primes=np.array([2, 3, 5, 7, 11, 13]))</code>","text":"<p>Generate the harmonic series where denominators are prime numbers repeated to achieve length n.</p> <p>Arguments: n -- length of the harmonic series primes -- array of prime numbers (default [2, 3, 5, 7, 11, 13])</p> Source code in <code>src/iimrp/harmonics.py</code> <pre><code>def prime_harmonic_series(n, primes=np.array([2, 3, 5, 7, 11, 13])):\n    \"\"\"\n    Generate the harmonic series where denominators are prime numbers repeated to achieve length n.\n\n    Arguments:\n    n -- length of the harmonic series\n    primes -- array of prime numbers (default [2, 3, 5, 7, 11, 13])  \n    \"\"\"  \n    return np.array([1 / i for i in primes for _ in range(int(n/len(primes)))])\n</code></pre>"},{"location":"reference/iimrp/harmonics/#iimrp.harmonics.prime_power_series","title":"<code>prime_power_series(n, primes=np.array([2, 3, 5, 7, 11, 13]))</code>","text":"<p>Generate the harmonic series where denominators are prime numbers raised to the power their index.</p> <p>Arguments: n -- length of the harmonic series primes -- array of prime numbers (default [2, 3, 5, 7, 11, 13])</p> Source code in <code>src/iimrp/harmonics.py</code> <pre><code>def prime_power_series(n, primes=np.array([2, 3, 5, 7, 11, 13])):\n    \"\"\"\n    Generate the harmonic series where denominators are prime numbers raised to the power their index.\n\n    Arguments:\n    n -- length of the harmonic series\n    primes -- array of prime numbers (default [2, 3, 5, 7, 11, 13])  \n    \"\"\"  \n    return np.array([1 / np.power(primes[i%len(primes)], i+1) for i in range(n)]) \n</code></pre>"},{"location":"reference/iimrp/harmonics/#iimrp.harmonics.reciprocals_of_triangular_numbers","title":"<code>reciprocals_of_triangular_numbers(n)</code>","text":"<p>Generate the harmonic series where each denominator is a reciprocal of triangular number.</p> <p>Arguments: n -- limiting value for the triangular number sequence and length of the harmonic series</p> Source code in <code>src/iimrp/harmonics.py</code> <pre><code>def reciprocals_of_triangular_numbers(n):\n    \"\"\"\n    Generate the harmonic series where each denominator is a reciprocal of triangular number.\n\n    Arguments:\n    n -- limiting value for the triangular number sequence and length of the harmonic series\n    \"\"\"  \n    return np.array([1 / ((i * (i + 1)) / (2*n)) for i in range(1, n+1)])\n</code></pre>"},{"location":"reference/iimrp/harmonics/#iimrp.harmonics.reverse_basic_harmonic_series","title":"<code>reverse_basic_harmonic_series(n)</code>","text":"<p>Generate the harmonic series where denominators are descended from n to 1.</p> <p>Arguments: n -- limiting value for the denominators and length of the harmonic series</p> Source code in <code>src/iimrp/harmonics.py</code> <pre><code>def reverse_basic_harmonic_series(n):\n    \"\"\"\n    Generate the harmonic series where denominators are descended from n to 1.\n\n    Arguments:\n    n -- limiting value for the denominators and length of the harmonic series\n    \"\"\"  \n    return np.array([1 / (n - i) for i in range(n)])\n</code></pre>"},{"location":"reference/iimrp/harmonics/#iimrp.harmonics.reverse_odd_harmonic_series","title":"<code>reverse_odd_harmonic_series(n)</code>","text":"<p>Generate the harmonic series where odd denominators are descended from 2n-1 to 1.</p> <p>Arguments: n -- half limit for the denominators and length of the harmonic series</p> Source code in <code>src/iimrp/harmonics.py</code> <pre><code>def reverse_odd_harmonic_series(n):\n    \"\"\"\n    Generate the harmonic series where odd denominators are descended from 2n-1 to 1.\n\n    Arguments:\n    n -- half limit for the denominators and length of the harmonic series\n    \"\"\"  \n    return np.array([1 / (2 * (n - i) + 1) for i in range(n)]) \n</code></pre>"},{"location":"reference/iimrp/harmonics/#iimrp.harmonics.shifted_harmonic_series","title":"<code>shifted_harmonic_series(n, shift=2)</code>","text":"<p>Generate the shifted harmonic series where each successive term is divided by i plus a shift.</p> <p>Arguments: n -- length of the harmonic series shift -- the value to shift the denominators by (default 2)</p> Source code in <code>src/iimrp/harmonics.py</code> <pre><code>def shifted_harmonic_series(n, shift=2):\n    \"\"\"\n    Generate the shifted harmonic series where each successive term is divided by i plus a shift.\n\n    Arguments:\n    n -- length of the harmonic series\n    shift -- the value to shift the denominators by (default 2)\n    \"\"\"  \n    return np.array([1 / (i + shift) for i in range(n)])\n</code></pre>"},{"location":"reference/iimrp/harmonics/#iimrp.harmonics.squared_harmonic_series","title":"<code>squared_harmonic_series(n)</code>","text":"<p>Generate the harmonic series where denominators are squares of integers from 0 to n-1.</p> <p>Arguments: n -- limiting value for the series</p> Source code in <code>src/iimrp/harmonics.py</code> <pre><code>def squared_harmonic_series(n):\n    \"\"\"\n    Generate the harmonic series where denominators are squares of integers from 0 to n-1.\n\n    Arguments:\n    n -- limiting value for the series\n    \"\"\"  \n    return np.array([1 / (i**2 + 1) for i in range(n)])\n</code></pre>"},{"location":"reference/iimrp/harmonics/#iimrp.harmonics.triangular_number_harmonic_series","title":"<code>triangular_number_harmonic_series(n)</code>","text":"<p>Generate the harmonic series where each denominator is a triangular number.</p> <p>Arguments: n -- limiting value for the triangular number sequence and length of the harmonic series</p> Source code in <code>src/iimrp/harmonics.py</code> <pre><code>def triangular_number_harmonic_series(n):\n    \"\"\"\n    Generate the harmonic series where each denominator is a triangular number.\n\n    Arguments:\n    n -- limiting value for the triangular number sequence and length of the harmonic series\n    \"\"\"  \n    return np.array([1 / ((i * (i + 1)) / 2) for i in range(1, n+1)])\n</code></pre>"},{"location":"reference/iimrp/iimrp/","title":"Iimrp","text":"Authors <p>Victor Shepardson Jack Armitage Intelligent Instruments Lab 2022</p>"},{"location":"reference/iimrp/iimrp/#iimrp.iimrp.MRP","title":"<code>MRP</code>","text":"<p>             Bases: <code>object</code></p> Source code in <code>src/iimrp/iimrp.py</code> <pre><code>class MRP(object):\n    def __init__(self, osc, settings=None, verbose=False):\n        # default settings\n        self.verbose = verbose\n        self.settings = {\n            'address': {\n                'port': 7770,\n                'ip': '127.0.0.1'\n            },\n            'voices': {\n                'max': 16, # for 16 cables\n                'rule': 'oldest' # oldest, lowest, highest, quietest...\n            },\n            'channel': 15, # real-time midi note ch (0-indexed)\n            'range': { 'start': 21, 'end': 108 }, # MIDI for piano keys 0-88\n            'qualities_max': 1.0,\n            'qualities_min': 0.0,\n            'heat_monitor': False\n        }\n        self.note_on_hex = 0x9F\n        self.note_off_hex = 0x8F\n        # custom settings\n        if settings is not None:\n            for k, v in settings.items():\n                self.settings[k] = v\n        self.print('MRP starting with settings:', self.settings)\n\n        # OSC reference and paths\n        self.osc = osc\n        if self.osc.get_client_by_name(\"mrp\") is None:\n            self.print(f\"MRP OSC client not found, creating one at {self.settings['address']['ip']}:{self.settings['address']['port']}\")\n            self.osc.create_client(\"mrp\", self.settings['address']['ip'], self.settings['address']['port'])\n        self.osc_paths = {\n            'midi': '/mrp/midi',\n            'qualities': {\n                'brightness':    '/mrp/quality/brightness',\n                'intensity':     '/mrp/quality/intensity',\n                'pitch':         '/mrp/quality/pitch',\n                'pitch_vibrato': '/mrp/quality/pitch/vibrato',\n                'harmonic':      '/mrp/quality/harmonic',\n                'harmonics_raw': '/mrp/quality/harmonics/raw'\n            },\n            'pedal': {\n                'damper':    '/mrp/pedal/damper',\n                'sostenuto': '/mrp/pedal/sostenuto'\n            },\n            'misc': {\n                'allnotesoff': '/mrp/allnotesoff'\n            },\n            'ui': {\n                'volume':     '/ui/volume', # float vol // 0-1, &gt;0.5 ? 4^((vol-0.5)/0.5) : 10^((vol-0.5)/0.5)\n                'volume_raw': '/ui/volume/raw' # float vol // 0-1, set volume directly\n            }\n        }\n        # internal state\n        self.notes = [] # state of each real-time midi note\n        self.note = { # template note\n            'channel': self.settings['channel'],\n            'status': NOTE_OFF,\n            'midi': {\n                'number': 0, # MIDI note number, not piano key number\n                'velocity': 0, # not in use by MRP PLL synth\n                'aftertouch_poly': 0, # not in use by MRP PLL synth\n                'aftertouch_channel': 0, # not in use by MRP PLL synth\n                'pitch_bend': 0 # not in use by MRP PLL synth\n            },\n            'qualities': {\n                'brightness': 0,\n                'intensity': 0,\n                'pitch': 0,\n                'pitch_vibrato': 0,\n                'harmonic': 0,\n                'harmonics_raw': []\n            }\n        }\n        self.voices = [] # active notes indexed chronologically\n        self.pedal = {\n            'damper': 0,\n            'sostenuto': 0\n        }\n        self.ui = {\n            'volume': 0,\n            'volume_raw': 0\n        }\n        self.program = 0 # current program (see MRP XML)\n        # init sequence\n        self.init_notes()\n        if self.settings['heat_monitor'] is True:\n            self.heat_monitor = MRPHeatMonitor(self)\n\n    def monitor(self):\n        if self.settings['heat_monitor'] is True:\n            self.heat_monitor()\n\n    def init_notes(self):\n        \"\"\"\n        initialise an array of notes in NOTE_OFF state,\n        equal in length to the number of piano keys in use\n        \"\"\"\n        self.notes = []\n        piano_keys = self.settings['range']['end'] - \\\n                     self.settings['range']['start'] + 1 # inclusive\n        for k in range(piano_keys):\n            note = self.note_create(\n                self.settings['range']['start'] + k, # MIDI note numbers\n                0\n            )\n            self.notes.append(note)\n        self.print(len(self.notes), 'notes created.')\n\n    \"\"\"\n    /mrp/midi\n    \"\"\"\n    def note_on(self, note, velocity=1, channel=None):\n        \"\"\"\n        check if note on is valid\n        add it as an active voice\n        construct a Note On message &amp; send over OSC\n        \"\"\"\n        if self.note_on_is_valid(note) == True:\n            self.voices_add(note)\n            if channel is None:\n                channel = self.settings['channel']\n            tmp = self.notes[self.note_index(note)]\n            tmp['status'] = NOTE_ON\n            tmp['channel'] = channel\n            tmp['midi']['velocity'] = velocity\n            path = self.osc_paths['midi']\n            self.print(path, 'Note On:', note, ', Velocity:', velocity)\n            self.osc.send(path, self.note_on_hex, note, velocity, client=\"mrp\")\n            return tmp\n        else:\n            self.print('note_on(): invalid Note On', note)\n            return None\n\n    def note_off(self, note, velocity=0, channel=None):\n        \"\"\"\n        check if note off is valid\n        remove it as an active voice\n        construct a Note Off message &amp; send over OSC\n        \"\"\"\n        if self.note_off_is_valid(note) == True:\n            if note in self.voices:\n                self.voices_remove(note)\n            if channel is None:\n                channel = self.settings['channel']\n            tmp = self.notes[self.note_index(note)]\n            tmp['status'] = NOTE_OFF\n            tmp['channel'] = channel\n            tmp['midi']['velocity'] = velocity\n            path = self.osc_paths['midi']\n            self.print(path, 'Note Off:', note)\n            self.osc.send(path, self.note_off_hex, note, velocity, client=\"mrp\")\n            return tmp\n        else:\n            self.print('note_off(): invalid Note Off', note)\n            return None\n\n    def notes_on(self, notes, velocities=None):\n        vmax = self.settings['voices']['max']\n        if len(notes)+1 &gt; vmax:\n            if velocities == None:\n                [self.note_on(n) for n in notes]\n            else:\n                [self.note_on(n, velocities[i]) for i,n in enumerate(notes)]\n        else:\n            print('notes_on(): too many notes', notes)\n\n    def notes_off(self, notes, channel=None):\n        [self.note_off(n) for n in notes]\n\n    # def control_change(self, controller, value, channel=None):\n    #     \"\"\"\n    #     construct MIDI CC message &amp; send over OSC\n    #     \"\"\"\n    #     if channel is None:\n    #         channel = self.settings['channel']\n    #     m = mido.Message(\n    #         'control_change',\n    #         channel=channel,\n    #         controller=controller,\n    #         value=value\n    #     )\n    #     path = self.osc_paths['midi']\n    #     self.print(path, 'Control Change:', *m.bytes())\n    #     self.osc.send(path, *m.bytes(), client=\"mrp\")\n\n    # def program_change(self, program, channel=None):\n    #     \"\"\"\n    #     update program state\n    #     construct MIDI program change message \n    #     &amp; send over OSC\n    #     \"\"\"\n    #     if channel is None:\n    #         channel = self.settings['channel']\n    #     self.program = program\n    #     m = mido.Message(\n    #         'program_change',\n    #         channel=channel,\n    #         program=program\n    #     )\n    #     path = self.osc_paths['midi']\n    #     self.print(path, 'Program Change:', *m.bytes())\n    #     self.osc.send(path, *m.bytes(), client=\"mrp\")\n\n    \"\"\"\n    /mrp/qualities\n    \"\"\"\n    def set_note_quality(self, note: int, quality: str, value: float, relative=False, channel=None):\n        \"\"\"\n        Set a note's quality to a new value.\n\n        Example\n            set_note_quality(48, 'brightness', 0.5)\n\n        Args\n            note (int): MIDI note number\n            quality (string): name of quality to update, must be same as key in osc_paths\n            value (float): value of quality\n            relative (bool): replace the value or add it to the current value\n            channel (int): which MIDI channel to send on\n        \"\"\"\n        if isinstance(quality, str):\n            if self.note_msg_is_valid(note) == True:\n                if channel is None:\n                    channel = self.settings['channel']\n                tmp = self.notes[self.note_index(note)]\n                if isinstance(value, list) or isinstance(value, np.ndarray): # e.g. /harmonics/raw\n                    if relative is True:\n                        self.print('set_note_quality(): relative updating of lists not supported')\n                        # if (len(tmp['qualities'][quality]) &gt; 0):\n                        #     for i, q in enumerate(tmp['qualities'][quality]):\n                        #         tmp['qualities'][quality][i] += self.quality_clamp(value[i])\n                        #         value.pop(i)\n                        #     for i, v in enumerate(value):\n                        #         tmp['qualities'][quality].append(value[i])\n                        # else:\n                        #     tmp['qualities'][quality] = [self.quality_clamp(v) for v in value]\n                    else:\n                        tmp['qualities'][quality] = [self.quality_clamp(v) for v in value]\n                    path = self.osc_paths['qualities'][quality]\n                    self.print(path, channel, note, *tmp['qualities'][quality])\n                    self.osc.send(path, channel, note, *tmp['qualities'][quality], client=\"mrp\")\n                    return tmp\n                else:\n                    if relative is True:\n                        tmp['qualities'][quality] = self.quality_clamp(value + tmp['qualities'][quality])\n                    else:\n                        tmp['qualities'][quality] = self.quality_clamp(value)\n                    path = self.osc_paths['qualities'][quality]\n                    self.print(path, channel, note, tmp['qualities'][quality])\n                    self.osc.send(path, channel, note, tmp['qualities'][quality], client=\"mrp\")\n                    return tmp\n            else:\n                self.print('set_note_quality(): invalid message:', quality, note, value)\n                return None\n        else:\n            self.print('set_note_quality(): \"quality\" is not a string:', quality)\n            return None\n\n    def set_quality(self, quality, value, relative=False, channel=None):\n        \"\"\"\n        Update quality of all active notes to a new value.\n\n        Example\n            set_quality('brightness', 0.5)\n\n        Args\n            quality (string): name of quality to update, must be same as key in osc_paths\n            value (float): value of quality\n            relative (bool): replace the value or add it to the current value\n            channel (int): which MIDI channel to send on\n        \"\"\"\n        if isinstance(quality, str):\n            active_notes = self.note_on_numbers()\n            changed_notes = []\n            for note in active_notes:\n                changed_note = self.set_note_quality(self, note, quality, value, relative, channel)\n                changed_notes.append(changed_note)\n            return changed_notes\n        else:\n            print('quality_update(): \"quality\" is not a string:', quality)\n            return None\n\n    def set_note_qualities(self, note, qualities, relative=False, channel=None):\n        \"\"\"\n        Update a note's qualities to a new set of values.\n\n        Example\n            set_note_qualities(48, {\n                'brightness': 0.5,\n                'intensity': 0.6,\n                'harmonics_raw': [0.2, 0.3, 0.4]\n            })\n\n        Args\n            note (int): MIDI note number\n            qualities (dict): dict of qualities in key (string):value (float) pairs to update, \n                              must be same as key in osc_paths\n            relative (bool): replace the value or add it to the current value\n            channel (int): which MIDI channel to send on\n        \"\"\"\n        if isinstance(qualities, dict):\n            if self.note_msg_is_valid(note) == True:\n                if channel is None:\n                    channel = self.settings['channel']\n                tmp = self.notes[self.note_index(note)]\n                for q, v in qualities.items():\n                    if isinstance(v, list) or isinstance(v, np.ndarray): # e.g. /harmonics/raw\n                        if relative is True:\n                            self.print('quality_update(): relative updating of lists not supported')\n                        else:\n                            tmp['qualities'][q] = [self.quality_clamp(i) for i in v]\n                        path = self.osc_paths['qualities'][q]\n                        self.print(path, channel, note, *tmp['qualities'][q])\n                        self.osc.send(path, channel, note, *tmp['qualities'][q], client=\"mrp\")\n                    else:\n                        if relative is True:\n                            tmp['qualities'][q] = self.quality_clamp(v, tmp['qualities'][q])\n                        else:\n                            tmp['qualities'][q] = self.quality_clamp(v)\n                        path = self.osc_paths['qualities'][q]\n                        self.print(path, channel, note, tmp['qualities'][q])\n                        self.osc.send(path, channel, note, tmp['qualities'][q], client=\"mrp\")\n                return tmp\n            else:\n                self.print('quality_update(): invalid message:', note, qualities)\n                return None\n        else:\n            self.print('quality_update(): \"qualities\" is not an object:', note, qualities)\n            return None\n\n    def set_qualities(self, qualities, relative=False, channel=None):\n        \"\"\"\n        Update the qualities for all active notes to a new set of values.\n\n        Example\n            set_qualities({\n                'brightness': 0.5,\n                'intensity': 0.6,\n                'harmonics_raw': [0.2, 0.3, 0.4]\n            })\n\n        Args\n            qualities (dict): dict of qualities in key (string):value (float) pairs to update, \n                              must be same as key in osc_paths\n            relative (bool): replace the value or add it to the current value\n            channel (int): which MIDI channel to send on\n        \"\"\"\n        if isinstance(qualities, dict):\n            active_notes = self.note_on_numbers()\n            changed_notes = []\n            for note in active_notes:\n                changed_note = self.qualities_update(self, qualities, relative, channel)\n                changed_notes.append(changed_note)\n            return changed_notes\n        else:\n            print('quality_update(): \"qualities\" is not an object:', note, qualities)\n            return None\n\n    def get_note_quality(self, note:int, quality:str) -&gt; float:\n        \"\"\"\n        Return the value of a note's quality.\n\n        Example\n            get_note_quality(48, 'brightness')\n\n        Args\n            note (int): MIDI note number\n            quality (string): name of quality to get, must be same as key in osc_paths\n\n        Returns\n            float: value of quality\n        \"\"\"\n        return self.notes[self.note_index(note)]['qualities'][quality]\n\n    def get_note_qualities(self, note:int) -&gt; dict:\n        \"\"\"\n        Return the values of a note's qualities.\n\n        Example\n            get_note_qualities(48)\n\n        Args\n            note (int): MIDI note number\n\n        Returns\n            dict: dict of qualities in key (string):value (float) pairs\n        \"\"\"\n        return self.notes[self.note_index(note)]['qualities']\n\n    def get_quality(self, quality:str) -&gt; dict:\n        \"\"\"\n        Return values of a quality for all active notes.\n\n        Example\n            get_quality('brightness')\n\n        Args\n            quality (string): name of quality to get, must be same as key in osc_paths\n\n        Returns\n            dict: note:quality in key (int):value (float) pairs\n        \"\"\"\n        active_notes = self.note_on_numbers()\n        return {n:self.get_note_quality(n, quality) for n in active_notes}\n\n    def get_qualities(self) -&gt; dict:\n        \"\"\"\n        Return values of all qualities for all active notes.\n\n        Example\n            get_qualities()\n\n        Returns\n            dict: note:qualities in key (int):value (dict) pairs\n        \"\"\"\n        active_notes = self.note_on_numbers()\n        return {n:self.get_note_qualities(n) for n in active_notes}\n\n    \"\"\"\n    /mrp/pedal\n    \"\"\"\n    def pedal_sostenuto(self, sostenuto):\n        \"\"\"\n        set pedal sostenuto value\n        \"\"\"\n        self.pedal.sostenuto = sostenuto\n        path = self.osc_paths['pedal']['sostenuto']\n        self.print(path, sostenuto)\n        self.osc.send(path, sostenuto, client=\"mrp\")\n\n    def pedal_damper(self, damper):\n        \"\"\"\n        set pedal damper value\n        \"\"\"\n        self.pedal.damper = damper\n        path = self.osc_paths['pedal']['damper']\n        self.print(path, damper)\n        self.osc.send(path, damper, client=\"mrp\")\n\n    \"\"\"\n    /mrp/* miscellaneous\n    \"\"\"\n    def all_notes_off(self):\n        \"\"\"\n        turn all notes off\n        \"\"\"\n        path = self.osc_paths['misc']['allnotesoff']\n        self.print(path)\n        self.osc.send(path, client=\"mrp\")\n        self.init_notes()\n        self.voices_reset()\n\n    \"\"\"\n    /mrp/ui\n    \"\"\"\n    def ui_volume(self, value):\n        \"\"\"\n        float vol // 0-1, &gt;0.5 ? 4^((vol-0.5)/0.5) : 10^((vol-0.5)/0.5)\n        \"\"\"\n        self.ui.volume = value\n        path = self.osc_paths['ui']['volume']\n        self.print(path, value)\n        self.osc.send(path, value, client=\"mrp\")\n\n    def ui_volume_raw(self, value):\n        \"\"\"\n        float vol // 0-1, set volume directly\n        \"\"\"\n        self.ui.volume_raw = value\n        path = self.osc_paths['ui']['volume_raw']\n        self.print(path, value)\n        self.osc.send(path, value, client=\"mrp\")\n\n    \"\"\"\n    note methods\n    \"\"\"\n    def note_create(self, n, velocity, channel=None):\n        \"\"\"\n        create and return a note object\n        \"\"\"\n        if channel is None:\n            channel = self.settings['channel']\n        note = copy.deepcopy(self.note)\n        note['midi']['number'] = n\n        note['midi']['velocity'] = velocity\n        return note\n\n    def note_is_in_range(self, note):\n        \"\"\"\n        check if a note is in valid range\n        \"\"\"\n        start = self.settings['range']['start']\n        end = self.settings['range']['end']\n        if start &gt; note or note &gt; end:\n            return False\n        return True\n\n    def note_is_off(self, note):\n        \"\"\"\n        check if a note is off\n        \"\"\"\n        index = note - self.settings['range']['start']\n        if self.notes[index]['status'] == NOTE_ON:\n            return False\n        return True\n\n    def note_index(self, note):\n        return note - self.settings['range']['start']\n\n    def note_on_numbers(self):\n        \"\"\"\n        return numbers of notes that are on\n        \"\"\"\n        return [\n            note['midi']['number'] \n            for note in self.notes \n            if note['status']==NOTE_ON]\n\n    def note_on_is_valid(self, note):\n        \"\"\"\n        check if the note is on &amp; in range\n        \"\"\"\n        if self.note_is_in_range(note) == True:\n            if self.note_is_off(note) == True:\n                return True\n            else:\n                self.print('note_on_is_valid(): note', note, 'is already on')\n                return False\n        else:\n            self.print('note_on_is_valid(): note', note, 'out of range')\n            return False    \n\n    def note_off_is_valid(self, note):\n        \"\"\"\n        check if the note is off &amp; in range\n        \"\"\"\n        if self.note_is_off(note) == False:\n            if self.note_is_in_range(note) == True:\n                return True\n            else:\n                self.print('note_off_is_valid(): note', note, 'out of range')\n                return False\n        else:\n            self.print('note_off_is_valid(): note', note, 'is already off')\n            return False\n\n    def note_msg_is_valid(self, note):\n        return self.note_off_is_valid(note)\n\n    \"\"\"\n    qualities methods\n    \"\"\"\n    def quality_clamp(self, value):\n        ### NOTE pitch, at least, can be negative or &gt; 1\n        return float(value)\n        # return float(clamp(value, self.settings['qualities_min'], self.settings['qualities_max']))\n\n    \"\"\"\n    voice methods\n    \"\"\"\n    def voices_add(self, note):\n        \"\"\"\n        add voices up to the maximum\n        then replace voices based on the rule\n        \"\"\"\n        if note in self.voices:\n            self.print('voices_add(): note already active')\n            return self.voices\n        if self.voices_count() &lt; self.settings['voices']['max']:\n            self.voices.append(note)\n        else:\n            rule = self.settings['voices']['rule']\n            match rule:\n                case 'oldest':\n                    oldest = self.voices[0]\n                    self.print('voices_add(): removing oldest', oldest)\n                    self.voices.pop(0)\n                    self.voices.append(note)\n                    self.note_off(oldest)\n                    return self.voices\n                case _: # lowest, highest, quietest, ...\n                    return self.voices\n        return self.voices\n\n    def voices_remove(self, note):\n        self.voices.remove(note)\n        return self.voices\n\n    def voices_update(self):\n        \"\"\"\n        reconstruct active voices list based on self.notes\n        \"\"\"\n        self.voices = self.note_on_numbers()\n        return self.voices\n\n    def voices_compare(self):\n        \"\"\"\n        check if voices and notes match\n        \"\"\"\n        note_on_numbers = self.note_on_numbers()\n        return note_on_numbers == self.voices, {'notes': note_on_numbers}, {'voices': self.voices}\n\n    def voices_reset(self):\n        self.voices = []\n\n    def voices_count(self):\n        return len(self.voices)\n\n    def voices_position(self, note):\n        \"\"\"\n        return position of a note in voice queue\n        \"\"\"\n        if note in self.voices:\n            return self.voices.index(note)\n        else:\n            self.print('voices_note_age(): note', note, 'is off')\n            return -1\n\n    '''\n    Getter utils\n    '''\n\n    def get_notes_on(self):\n        return [n['midi']['number'] for n in self.notes if n['status']==NOTE_ON]\n\n    def get_notes_status(self):\n        # return a dict of midi_number:status for all notes:\n        return {n['midi']['number']:n['status'] for n in self.notes}\n\n    def get_notes_harmonics(self):\n        return {n['midi']['number']:n['qualities']['harmonics_raw'] for n in self.notes}\n\n    \"\"\"\n    misc methods\n    \"\"\"\n    def cleanup(self):\n        print('MRP exiting...')\n        self.all_notes_off()\n\n    def print(self, *a, **kw):\n        \"\"\"verbose debug printing\"\"\"\n        if self.verbose: print(*a, **kw)\n</code></pre>"},{"location":"reference/iimrp/iimrp/#iimrp.iimrp.MRP.all_notes_off","title":"<code>all_notes_off()</code>","text":"<p>turn all notes off</p> Source code in <code>src/iimrp/iimrp.py</code> <pre><code>def all_notes_off(self):\n    \"\"\"\n    turn all notes off\n    \"\"\"\n    path = self.osc_paths['misc']['allnotesoff']\n    self.print(path)\n    self.osc.send(path, client=\"mrp\")\n    self.init_notes()\n    self.voices_reset()\n</code></pre>"},{"location":"reference/iimrp/iimrp/#iimrp.iimrp.MRP.get_note_qualities","title":"<code>get_note_qualities(note)</code>","text":"<p>Return the values of a note's qualities.</p> <p>Example     get_note_qualities(48)</p> <p>Args     note (int): MIDI note number</p> <p>Returns     dict: dict of qualities in key (string):value (float) pairs</p> Source code in <code>src/iimrp/iimrp.py</code> <pre><code>def get_note_qualities(self, note:int) -&gt; dict:\n    \"\"\"\n    Return the values of a note's qualities.\n\n    Example\n        get_note_qualities(48)\n\n    Args\n        note (int): MIDI note number\n\n    Returns\n        dict: dict of qualities in key (string):value (float) pairs\n    \"\"\"\n    return self.notes[self.note_index(note)]['qualities']\n</code></pre>"},{"location":"reference/iimrp/iimrp/#iimrp.iimrp.MRP.get_note_quality","title":"<code>get_note_quality(note, quality)</code>","text":"<p>Return the value of a note's quality.</p> <p>Example     get_note_quality(48, 'brightness')</p> <p>Args     note (int): MIDI note number     quality (string): name of quality to get, must be same as key in osc_paths</p> <p>Returns     float: value of quality</p> Source code in <code>src/iimrp/iimrp.py</code> <pre><code>def get_note_quality(self, note:int, quality:str) -&gt; float:\n    \"\"\"\n    Return the value of a note's quality.\n\n    Example\n        get_note_quality(48, 'brightness')\n\n    Args\n        note (int): MIDI note number\n        quality (string): name of quality to get, must be same as key in osc_paths\n\n    Returns\n        float: value of quality\n    \"\"\"\n    return self.notes[self.note_index(note)]['qualities'][quality]\n</code></pre>"},{"location":"reference/iimrp/iimrp/#iimrp.iimrp.MRP.get_qualities","title":"<code>get_qualities()</code>","text":"<p>Return values of all qualities for all active notes.</p> <p>Example     get_qualities()</p> <p>Returns     dict: note:qualities in key (int):value (dict) pairs</p> Source code in <code>src/iimrp/iimrp.py</code> <pre><code>def get_qualities(self) -&gt; dict:\n    \"\"\"\n    Return values of all qualities for all active notes.\n\n    Example\n        get_qualities()\n\n    Returns\n        dict: note:qualities in key (int):value (dict) pairs\n    \"\"\"\n    active_notes = self.note_on_numbers()\n    return {n:self.get_note_qualities(n) for n in active_notes}\n</code></pre>"},{"location":"reference/iimrp/iimrp/#iimrp.iimrp.MRP.get_quality","title":"<code>get_quality(quality)</code>","text":"<p>Return values of a quality for all active notes.</p> <p>Example     get_quality('brightness')</p> <p>Args     quality (string): name of quality to get, must be same as key in osc_paths</p> <p>Returns     dict: note:quality in key (int):value (float) pairs</p> Source code in <code>src/iimrp/iimrp.py</code> <pre><code>def get_quality(self, quality:str) -&gt; dict:\n    \"\"\"\n    Return values of a quality for all active notes.\n\n    Example\n        get_quality('brightness')\n\n    Args\n        quality (string): name of quality to get, must be same as key in osc_paths\n\n    Returns\n        dict: note:quality in key (int):value (float) pairs\n    \"\"\"\n    active_notes = self.note_on_numbers()\n    return {n:self.get_note_quality(n, quality) for n in active_notes}\n</code></pre>"},{"location":"reference/iimrp/iimrp/#iimrp.iimrp.MRP.init_notes","title":"<code>init_notes()</code>","text":"<p>initialise an array of notes in NOTE_OFF state, equal in length to the number of piano keys in use</p> Source code in <code>src/iimrp/iimrp.py</code> <pre><code>def init_notes(self):\n    \"\"\"\n    initialise an array of notes in NOTE_OFF state,\n    equal in length to the number of piano keys in use\n    \"\"\"\n    self.notes = []\n    piano_keys = self.settings['range']['end'] - \\\n                 self.settings['range']['start'] + 1 # inclusive\n    for k in range(piano_keys):\n        note = self.note_create(\n            self.settings['range']['start'] + k, # MIDI note numbers\n            0\n        )\n        self.notes.append(note)\n    self.print(len(self.notes), 'notes created.')\n</code></pre>"},{"location":"reference/iimrp/iimrp/#iimrp.iimrp.MRP.note_create","title":"<code>note_create(n, velocity, channel=None)</code>","text":"<p>create and return a note object</p> Source code in <code>src/iimrp/iimrp.py</code> <pre><code>def note_create(self, n, velocity, channel=None):\n    \"\"\"\n    create and return a note object\n    \"\"\"\n    if channel is None:\n        channel = self.settings['channel']\n    note = copy.deepcopy(self.note)\n    note['midi']['number'] = n\n    note['midi']['velocity'] = velocity\n    return note\n</code></pre>"},{"location":"reference/iimrp/iimrp/#iimrp.iimrp.MRP.note_is_in_range","title":"<code>note_is_in_range(note)</code>","text":"<p>check if a note is in valid range</p> Source code in <code>src/iimrp/iimrp.py</code> <pre><code>def note_is_in_range(self, note):\n    \"\"\"\n    check if a note is in valid range\n    \"\"\"\n    start = self.settings['range']['start']\n    end = self.settings['range']['end']\n    if start &gt; note or note &gt; end:\n        return False\n    return True\n</code></pre>"},{"location":"reference/iimrp/iimrp/#iimrp.iimrp.MRP.note_is_off","title":"<code>note_is_off(note)</code>","text":"<p>check if a note is off</p> Source code in <code>src/iimrp/iimrp.py</code> <pre><code>def note_is_off(self, note):\n    \"\"\"\n    check if a note is off\n    \"\"\"\n    index = note - self.settings['range']['start']\n    if self.notes[index]['status'] == NOTE_ON:\n        return False\n    return True\n</code></pre>"},{"location":"reference/iimrp/iimrp/#iimrp.iimrp.MRP.note_off","title":"<code>note_off(note, velocity=0, channel=None)</code>","text":"<p>check if note off is valid remove it as an active voice construct a Note Off message &amp; send over OSC</p> Source code in <code>src/iimrp/iimrp.py</code> <pre><code>def note_off(self, note, velocity=0, channel=None):\n    \"\"\"\n    check if note off is valid\n    remove it as an active voice\n    construct a Note Off message &amp; send over OSC\n    \"\"\"\n    if self.note_off_is_valid(note) == True:\n        if note in self.voices:\n            self.voices_remove(note)\n        if channel is None:\n            channel = self.settings['channel']\n        tmp = self.notes[self.note_index(note)]\n        tmp['status'] = NOTE_OFF\n        tmp['channel'] = channel\n        tmp['midi']['velocity'] = velocity\n        path = self.osc_paths['midi']\n        self.print(path, 'Note Off:', note)\n        self.osc.send(path, self.note_off_hex, note, velocity, client=\"mrp\")\n        return tmp\n    else:\n        self.print('note_off(): invalid Note Off', note)\n        return None\n</code></pre>"},{"location":"reference/iimrp/iimrp/#iimrp.iimrp.MRP.note_off_is_valid","title":"<code>note_off_is_valid(note)</code>","text":"<p>check if the note is off &amp; in range</p> Source code in <code>src/iimrp/iimrp.py</code> <pre><code>def note_off_is_valid(self, note):\n    \"\"\"\n    check if the note is off &amp; in range\n    \"\"\"\n    if self.note_is_off(note) == False:\n        if self.note_is_in_range(note) == True:\n            return True\n        else:\n            self.print('note_off_is_valid(): note', note, 'out of range')\n            return False\n    else:\n        self.print('note_off_is_valid(): note', note, 'is already off')\n        return False\n</code></pre>"},{"location":"reference/iimrp/iimrp/#iimrp.iimrp.MRP.note_on","title":"<code>note_on(note, velocity=1, channel=None)</code>","text":"<p>check if note on is valid add it as an active voice construct a Note On message &amp; send over OSC</p> Source code in <code>src/iimrp/iimrp.py</code> <pre><code>def note_on(self, note, velocity=1, channel=None):\n    \"\"\"\n    check if note on is valid\n    add it as an active voice\n    construct a Note On message &amp; send over OSC\n    \"\"\"\n    if self.note_on_is_valid(note) == True:\n        self.voices_add(note)\n        if channel is None:\n            channel = self.settings['channel']\n        tmp = self.notes[self.note_index(note)]\n        tmp['status'] = NOTE_ON\n        tmp['channel'] = channel\n        tmp['midi']['velocity'] = velocity\n        path = self.osc_paths['midi']\n        self.print(path, 'Note On:', note, ', Velocity:', velocity)\n        self.osc.send(path, self.note_on_hex, note, velocity, client=\"mrp\")\n        return tmp\n    else:\n        self.print('note_on(): invalid Note On', note)\n        return None\n</code></pre>"},{"location":"reference/iimrp/iimrp/#iimrp.iimrp.MRP.note_on_is_valid","title":"<code>note_on_is_valid(note)</code>","text":"<p>check if the note is on &amp; in range</p> Source code in <code>src/iimrp/iimrp.py</code> <pre><code>def note_on_is_valid(self, note):\n    \"\"\"\n    check if the note is on &amp; in range\n    \"\"\"\n    if self.note_is_in_range(note) == True:\n        if self.note_is_off(note) == True:\n            return True\n        else:\n            self.print('note_on_is_valid(): note', note, 'is already on')\n            return False\n    else:\n        self.print('note_on_is_valid(): note', note, 'out of range')\n        return False    \n</code></pre>"},{"location":"reference/iimrp/iimrp/#iimrp.iimrp.MRP.note_on_numbers","title":"<code>note_on_numbers()</code>","text":"<p>return numbers of notes that are on</p> Source code in <code>src/iimrp/iimrp.py</code> <pre><code>def note_on_numbers(self):\n    \"\"\"\n    return numbers of notes that are on\n    \"\"\"\n    return [\n        note['midi']['number'] \n        for note in self.notes \n        if note['status']==NOTE_ON]\n</code></pre>"},{"location":"reference/iimrp/iimrp/#iimrp.iimrp.MRP.pedal_damper","title":"<code>pedal_damper(damper)</code>","text":"<p>set pedal damper value</p> Source code in <code>src/iimrp/iimrp.py</code> <pre><code>def pedal_damper(self, damper):\n    \"\"\"\n    set pedal damper value\n    \"\"\"\n    self.pedal.damper = damper\n    path = self.osc_paths['pedal']['damper']\n    self.print(path, damper)\n    self.osc.send(path, damper, client=\"mrp\")\n</code></pre>"},{"location":"reference/iimrp/iimrp/#iimrp.iimrp.MRP.pedal_sostenuto","title":"<code>pedal_sostenuto(sostenuto)</code>","text":"<p>set pedal sostenuto value</p> Source code in <code>src/iimrp/iimrp.py</code> <pre><code>def pedal_sostenuto(self, sostenuto):\n    \"\"\"\n    set pedal sostenuto value\n    \"\"\"\n    self.pedal.sostenuto = sostenuto\n    path = self.osc_paths['pedal']['sostenuto']\n    self.print(path, sostenuto)\n    self.osc.send(path, sostenuto, client=\"mrp\")\n</code></pre>"},{"location":"reference/iimrp/iimrp/#iimrp.iimrp.MRP.print","title":"<code>print(*a, **kw)</code>","text":"<p>verbose debug printing</p> Source code in <code>src/iimrp/iimrp.py</code> <pre><code>def print(self, *a, **kw):\n    \"\"\"verbose debug printing\"\"\"\n    if self.verbose: print(*a, **kw)\n</code></pre>"},{"location":"reference/iimrp/iimrp/#iimrp.iimrp.MRP.set_note_qualities","title":"<code>set_note_qualities(note, qualities, relative=False, channel=None)</code>","text":"<p>Update a note's qualities to a new set of values.</p> <p>Example     set_note_qualities(48, {         'brightness': 0.5,         'intensity': 0.6,         'harmonics_raw': [0.2, 0.3, 0.4]     })</p> <p>Args     note (int): MIDI note number     qualities (dict): dict of qualities in key (string):value (float) pairs to update,                        must be same as key in osc_paths     relative (bool): replace the value or add it to the current value     channel (int): which MIDI channel to send on</p> Source code in <code>src/iimrp/iimrp.py</code> <pre><code>def set_note_qualities(self, note, qualities, relative=False, channel=None):\n    \"\"\"\n    Update a note's qualities to a new set of values.\n\n    Example\n        set_note_qualities(48, {\n            'brightness': 0.5,\n            'intensity': 0.6,\n            'harmonics_raw': [0.2, 0.3, 0.4]\n        })\n\n    Args\n        note (int): MIDI note number\n        qualities (dict): dict of qualities in key (string):value (float) pairs to update, \n                          must be same as key in osc_paths\n        relative (bool): replace the value or add it to the current value\n        channel (int): which MIDI channel to send on\n    \"\"\"\n    if isinstance(qualities, dict):\n        if self.note_msg_is_valid(note) == True:\n            if channel is None:\n                channel = self.settings['channel']\n            tmp = self.notes[self.note_index(note)]\n            for q, v in qualities.items():\n                if isinstance(v, list) or isinstance(v, np.ndarray): # e.g. /harmonics/raw\n                    if relative is True:\n                        self.print('quality_update(): relative updating of lists not supported')\n                    else:\n                        tmp['qualities'][q] = [self.quality_clamp(i) for i in v]\n                    path = self.osc_paths['qualities'][q]\n                    self.print(path, channel, note, *tmp['qualities'][q])\n                    self.osc.send(path, channel, note, *tmp['qualities'][q], client=\"mrp\")\n                else:\n                    if relative is True:\n                        tmp['qualities'][q] = self.quality_clamp(v, tmp['qualities'][q])\n                    else:\n                        tmp['qualities'][q] = self.quality_clamp(v)\n                    path = self.osc_paths['qualities'][q]\n                    self.print(path, channel, note, tmp['qualities'][q])\n                    self.osc.send(path, channel, note, tmp['qualities'][q], client=\"mrp\")\n            return tmp\n        else:\n            self.print('quality_update(): invalid message:', note, qualities)\n            return None\n    else:\n        self.print('quality_update(): \"qualities\" is not an object:', note, qualities)\n        return None\n</code></pre>"},{"location":"reference/iimrp/iimrp/#iimrp.iimrp.MRP.set_note_quality","title":"<code>set_note_quality(note, quality, value, relative=False, channel=None)</code>","text":"<p>Set a note's quality to a new value.</p> <p>Example     set_note_quality(48, 'brightness', 0.5)</p> <p>Args     note (int): MIDI note number     quality (string): name of quality to update, must be same as key in osc_paths     value (float): value of quality     relative (bool): replace the value or add it to the current value     channel (int): which MIDI channel to send on</p> Source code in <code>src/iimrp/iimrp.py</code> <pre><code>def set_note_quality(self, note: int, quality: str, value: float, relative=False, channel=None):\n    \"\"\"\n    Set a note's quality to a new value.\n\n    Example\n        set_note_quality(48, 'brightness', 0.5)\n\n    Args\n        note (int): MIDI note number\n        quality (string): name of quality to update, must be same as key in osc_paths\n        value (float): value of quality\n        relative (bool): replace the value or add it to the current value\n        channel (int): which MIDI channel to send on\n    \"\"\"\n    if isinstance(quality, str):\n        if self.note_msg_is_valid(note) == True:\n            if channel is None:\n                channel = self.settings['channel']\n            tmp = self.notes[self.note_index(note)]\n            if isinstance(value, list) or isinstance(value, np.ndarray): # e.g. /harmonics/raw\n                if relative is True:\n                    self.print('set_note_quality(): relative updating of lists not supported')\n                    # if (len(tmp['qualities'][quality]) &gt; 0):\n                    #     for i, q in enumerate(tmp['qualities'][quality]):\n                    #         tmp['qualities'][quality][i] += self.quality_clamp(value[i])\n                    #         value.pop(i)\n                    #     for i, v in enumerate(value):\n                    #         tmp['qualities'][quality].append(value[i])\n                    # else:\n                    #     tmp['qualities'][quality] = [self.quality_clamp(v) for v in value]\n                else:\n                    tmp['qualities'][quality] = [self.quality_clamp(v) for v in value]\n                path = self.osc_paths['qualities'][quality]\n                self.print(path, channel, note, *tmp['qualities'][quality])\n                self.osc.send(path, channel, note, *tmp['qualities'][quality], client=\"mrp\")\n                return tmp\n            else:\n                if relative is True:\n                    tmp['qualities'][quality] = self.quality_clamp(value + tmp['qualities'][quality])\n                else:\n                    tmp['qualities'][quality] = self.quality_clamp(value)\n                path = self.osc_paths['qualities'][quality]\n                self.print(path, channel, note, tmp['qualities'][quality])\n                self.osc.send(path, channel, note, tmp['qualities'][quality], client=\"mrp\")\n                return tmp\n        else:\n            self.print('set_note_quality(): invalid message:', quality, note, value)\n            return None\n    else:\n        self.print('set_note_quality(): \"quality\" is not a string:', quality)\n        return None\n</code></pre>"},{"location":"reference/iimrp/iimrp/#iimrp.iimrp.MRP.set_qualities","title":"<code>set_qualities(qualities, relative=False, channel=None)</code>","text":"<p>Update the qualities for all active notes to a new set of values.</p> <p>Example     set_qualities({         'brightness': 0.5,         'intensity': 0.6,         'harmonics_raw': [0.2, 0.3, 0.4]     })</p> <p>Args     qualities (dict): dict of qualities in key (string):value (float) pairs to update,                        must be same as key in osc_paths     relative (bool): replace the value or add it to the current value     channel (int): which MIDI channel to send on</p> Source code in <code>src/iimrp/iimrp.py</code> <pre><code>def set_qualities(self, qualities, relative=False, channel=None):\n    \"\"\"\n    Update the qualities for all active notes to a new set of values.\n\n    Example\n        set_qualities({\n            'brightness': 0.5,\n            'intensity': 0.6,\n            'harmonics_raw': [0.2, 0.3, 0.4]\n        })\n\n    Args\n        qualities (dict): dict of qualities in key (string):value (float) pairs to update, \n                          must be same as key in osc_paths\n        relative (bool): replace the value or add it to the current value\n        channel (int): which MIDI channel to send on\n    \"\"\"\n    if isinstance(qualities, dict):\n        active_notes = self.note_on_numbers()\n        changed_notes = []\n        for note in active_notes:\n            changed_note = self.qualities_update(self, qualities, relative, channel)\n            changed_notes.append(changed_note)\n        return changed_notes\n    else:\n        print('quality_update(): \"qualities\" is not an object:', note, qualities)\n        return None\n</code></pre>"},{"location":"reference/iimrp/iimrp/#iimrp.iimrp.MRP.set_quality","title":"<code>set_quality(quality, value, relative=False, channel=None)</code>","text":"<p>Update quality of all active notes to a new value.</p> <p>Example     set_quality('brightness', 0.5)</p> <p>Args     quality (string): name of quality to update, must be same as key in osc_paths     value (float): value of quality     relative (bool): replace the value or add it to the current value     channel (int): which MIDI channel to send on</p> Source code in <code>src/iimrp/iimrp.py</code> <pre><code>def set_quality(self, quality, value, relative=False, channel=None):\n    \"\"\"\n    Update quality of all active notes to a new value.\n\n    Example\n        set_quality('brightness', 0.5)\n\n    Args\n        quality (string): name of quality to update, must be same as key in osc_paths\n        value (float): value of quality\n        relative (bool): replace the value or add it to the current value\n        channel (int): which MIDI channel to send on\n    \"\"\"\n    if isinstance(quality, str):\n        active_notes = self.note_on_numbers()\n        changed_notes = []\n        for note in active_notes:\n            changed_note = self.set_note_quality(self, note, quality, value, relative, channel)\n            changed_notes.append(changed_note)\n        return changed_notes\n    else:\n        print('quality_update(): \"quality\" is not a string:', quality)\n        return None\n</code></pre>"},{"location":"reference/iimrp/iimrp/#iimrp.iimrp.MRP.ui_volume","title":"<code>ui_volume(value)</code>","text":"<p>float vol // 0-1, &gt;0.5 ? 4^((vol-0.5)/0.5) : 10^((vol-0.5)/0.5)</p> Source code in <code>src/iimrp/iimrp.py</code> <pre><code>def ui_volume(self, value):\n    \"\"\"\n    float vol // 0-1, &gt;0.5 ? 4^((vol-0.5)/0.5) : 10^((vol-0.5)/0.5)\n    \"\"\"\n    self.ui.volume = value\n    path = self.osc_paths['ui']['volume']\n    self.print(path, value)\n    self.osc.send(path, value, client=\"mrp\")\n</code></pre>"},{"location":"reference/iimrp/iimrp/#iimrp.iimrp.MRP.ui_volume_raw","title":"<code>ui_volume_raw(value)</code>","text":"<p>float vol // 0-1, set volume directly</p> Source code in <code>src/iimrp/iimrp.py</code> <pre><code>def ui_volume_raw(self, value):\n    \"\"\"\n    float vol // 0-1, set volume directly\n    \"\"\"\n    self.ui.volume_raw = value\n    path = self.osc_paths['ui']['volume_raw']\n    self.print(path, value)\n    self.osc.send(path, value, client=\"mrp\")\n</code></pre>"},{"location":"reference/iimrp/iimrp/#iimrp.iimrp.MRP.voices_add","title":"<code>voices_add(note)</code>","text":"<p>add voices up to the maximum then replace voices based on the rule</p> Source code in <code>src/iimrp/iimrp.py</code> <pre><code>def voices_add(self, note):\n    \"\"\"\n    add voices up to the maximum\n    then replace voices based on the rule\n    \"\"\"\n    if note in self.voices:\n        self.print('voices_add(): note already active')\n        return self.voices\n    if self.voices_count() &lt; self.settings['voices']['max']:\n        self.voices.append(note)\n    else:\n        rule = self.settings['voices']['rule']\n        match rule:\n            case 'oldest':\n                oldest = self.voices[0]\n                self.print('voices_add(): removing oldest', oldest)\n                self.voices.pop(0)\n                self.voices.append(note)\n                self.note_off(oldest)\n                return self.voices\n            case _: # lowest, highest, quietest, ...\n                return self.voices\n    return self.voices\n</code></pre>"},{"location":"reference/iimrp/iimrp/#iimrp.iimrp.MRP.voices_compare","title":"<code>voices_compare()</code>","text":"<p>check if voices and notes match</p> Source code in <code>src/iimrp/iimrp.py</code> <pre><code>def voices_compare(self):\n    \"\"\"\n    check if voices and notes match\n    \"\"\"\n    note_on_numbers = self.note_on_numbers()\n    return note_on_numbers == self.voices, {'notes': note_on_numbers}, {'voices': self.voices}\n</code></pre>"},{"location":"reference/iimrp/iimrp/#iimrp.iimrp.MRP.voices_position","title":"<code>voices_position(note)</code>","text":"<p>return position of a note in voice queue</p> Source code in <code>src/iimrp/iimrp.py</code> <pre><code>def voices_position(self, note):\n    \"\"\"\n    return position of a note in voice queue\n    \"\"\"\n    if note in self.voices:\n        return self.voices.index(note)\n    else:\n        self.print('voices_note_age(): note', note, 'is off')\n        return -1\n</code></pre>"},{"location":"reference/iimrp/iimrp/#iimrp.iimrp.MRP.voices_update","title":"<code>voices_update()</code>","text":"<p>reconstruct active voices list based on self.notes</p> Source code in <code>src/iimrp/iimrp.py</code> <pre><code>def voices_update(self):\n    \"\"\"\n    reconstruct active voices list based on self.notes\n    \"\"\"\n    self.voices = self.note_on_numbers()\n    return self.voices\n</code></pre>"},{"location":"reference/iimrp/thermal/","title":"Thermal","text":""},{"location":"reference/iimrp/thermal/#iimrp.thermal.MRPHeatMonitor","title":"<code>MRPHeatMonitor</code>","text":"<p>This is an 'unverified' prototype of a 'heat monitor' for the MRP. It is simulation-based, i.e. it does not use any real temperature data. It works by simulating the heat score of a note based on the harmonics being played. The heat score increases when the note is played and decreases when the note is not played. A note is then decided to be either eligible or ineligible to be played based on its heat score.</p> Source code in <code>src/iimrp/thermal.py</code> <pre><code>class MRPHeatMonitor:\n    \"\"\"\n    This is an 'unverified' prototype of a 'heat monitor' for the MRP.\n    It is simulation-based, i.e. it does not use any real temperature data.\n    It works by simulating the heat score of a note based on the harmonics being played.\n    The heat score increases when the note is played and decreases when the note is not played.\n    A note is then decided to be either eligible or ineligible to be played based on its heat score.\n    \"\"\"\n    def __init__(self, mrp, **kwargs) -&gt; None:\n        self.mrp = mrp\n        self.settings = self.mrp.settings\n        self.notes = [MRPNoteHeatMonitor(n) for n in range(self.settings['range']['start'], self.settings['range']['end']+1)]\n\n    def heat_monitor_on(self):\n        self.settings['heat_monitor'] = True\n        if self.heat_monitor is None:\n            self.init_heat_monitor()\n\n    def heat_monitor_off(self):\n        self.settings['heat_monitor'] = False\n        self.heat_monitor = None\n\n    def heat_monitor_toggle(self):\n        self.settings['heat_monitor'] = not self.settings['heat_monitor']\n        if self.settings['heat_monitor'] is False:\n            self.heat_monitor_off()\n        else:\n            self.heat_monitor_on()\n\n    def heat_monitor_reset(self):\n        self.init_heat_monitor()\n\n    def monitor_heat(self):\n        if self.settings['heat_monitor'] is False: return\n        notes_status = self.mrp.get_notes_status()\n        notes_harmonics = self.mrp.get_notes_harmonics()\n        pretty_print_status = []\n        for note, on in notes_status.items():\n            heat = self.notes[note - self.settings['range']['start']]\n            _harmonics = notes_harmonics[note]\n            heat_prev = heat.heat_score\n            if on:\n                heat.update_heat_score_on(_harmonics)\n            else:\n                heat.update_heat_score_off()\n            heat_diff = heat.heat_score - heat_prev\n            heat.check_eligibility()\n            pretty_print_status.append((note, on, heat, heat.is_eligible))\n        self.pretty_print_heat_monitor(pretty_print_status)\n\n    def pretty_print_heat_monitor(self, pretty_print_status):\n        p_eligible = []\n        p_heat = []\n        p_on = []\n        p_note = []\n        for s in pretty_print_status:\n            h = round(s[2].heat_score)\n            h = f\"  {h}\" if h &lt; 10 else f\" {h}\"\n            e = \" \u2705\" if s[3] else \" \u274c\"\n            o = \" \ud83d\udfe9\" if s[1] else \" \ud83d\udfe5\"\n            n = f\" {s[0]}\" if s[0] &lt; 100 else f\"{s[0]}\"\n            p_eligible.append(e)\n            p_heat.append(h)\n            p_on.append(o)\n            p_note.append(n)\n        print(f\"{''.join(p_eligible)}\")\n        print(f\"{''.join(p_heat)}\")\n        print(f\"{''.join(p_on)}\")\n        print(f\"{''.join(p_note)}\")\n        print(\"_\"*(1+len(''.join(p_heat))))\n        print('===')\n\n    def __call__(self, *args: Any, **kwds: Any) -&gt; Any:\n        self.monitor_heat()\n</code></pre>"},{"location":"reference/iimrp/thermal/#iimrp.thermal.MRPNoteHeatMonitor","title":"<code>MRPNoteHeatMonitor</code>","text":"<p>A class to estimate the thermal state of an individual MRP note.</p>"},{"location":"reference/iimrp/thermal/#iimrp.thermal.MRPNoteHeatMonitor--attributes","title":"Attributes","text":"<p>midi_number : int     The MIDI number of the note. heat_score : float     The heat score of the note. last_played : float     The timestamp of the last time the note was played.</p> Source code in <code>src/iimrp/thermal.py</code> <pre><code>class MRPNoteHeatMonitor:\n    \"\"\"\n    A class to estimate the thermal state of an individual MRP note.\n\n    Attributes\n    ----------\n    midi_number : int\n        The MIDI number of the note.\n    heat_score : float\n        The heat score of the note.\n    last_played : float\n        The timestamp of the last time the note was played.\n    \"\"\"\n\n    def __init__(self, midi_number):\n        \"\"\"\n        Constructs all the necessary attributes for the note object.\n\n        Parameters\n        ----------\n        midi_number : int\n            The MIDI number of the note.\n        \"\"\"\n        self.start_time = time.time()\n        self.midi_number = midi_number\n        self.heat_score = 0\n        self.last_played = self.start_time\n        self.is_eligible = True\n\n    def calculate_harmonics_score(self, harmonics_array):\n        \"\"\"\n        Calculate the harmonics score based on the given array of harmonics.\n\n        Parameters\n        ----------\n        harmonics_array : numpy.array\n            The array of harmonics being played.\n\n        Returns\n        -------\n        float\n            The calculated harmonics score.\n        \"\"\"\n        return np.dot((len(harmonics_array) - np.arange(len(harmonics_array))), harmonics_array)\n\n    def update_heat_score_on(self, harmonics_array, current_time=None):\n        \"\"\"\n        Update the heat score for the note when it is being played.\n\n        Parameters\n        ----------\n        harmonics_array : numpy.array\n            The array of harmonics being played.\n        \"\"\"\n        if current_time is None:\n            current_time = time.time()\n        time_diff = current_time - self.last_played\n        heat_increase_amount = HEAT_INCREASE * time_diff\n        harmonics_scaling = HARMONICS_SCALAR * self.calculate_harmonics_score(harmonics_array)\n        # heat_score_prev = self.heat_score\n        self.heat_score += heat_increase_amount * harmonics_scaling\n        # heat_score_diff = self.heat_score - heat_score_prev\n        # print(f\"increase {heat_increase_amount:.4f} * harmonics {harmonics_scaling:.4f} = heat_score: {self.heat_score:.4f}, time_diff: {time_diff:.4f}\")\n        self.last_played = current_time\n\n    def update_heat_score_off(self, current_time=None):\n        \"\"\"\n        Update the heat score for the note when it is not being played.\n        \"\"\"\n        if current_time is None:\n            current_time = time.time()\n        if self.heat_score &gt; 0:\n            time_diff = current_time - self.last_played\n            heat_score_prev = self.heat_score\n            self.heat_score -= HEAT_DISSIPATION * time_diff\n            heat_score_diff = self.heat_score - heat_score_prev\n            # print(f\"heat_score: {self.heat_score:.1f} heat_score_diff: {heat_score_diff:.1f} time_diff: {time_diff:.1f}\")\n            if self.heat_score &lt; 0:\n                self.heat_score = 0\n        # self.last_played = current_time\n\n    def check_eligibility(self, current_time=None):\n        \"\"\"\n        Check if the note is eligible to be played.\n\n        Returns\n        -------\n        bool\n            True if the note is eligible to be played, False otherwise.\n        \"\"\"\n        if current_time is None:\n            current_time = time.time()\n        time_diff = current_time - self.last_played\n        # print(f\"heat_score: {self.heat_score:.1f}, time_diff: {time_diff:.1f}\")\n        if self.heat_score &gt; OVERHEATING_RISK:\n            self.last_played = current_time + COOLING_PERIOD\n            self.is_eligible = False\n            # print(f\"RESULT self.heat_score &gt; OVERHEATING_RISK: {self.heat_score} &gt; {OVERHEATING_RISK}\")\n        elif time_diff &gt; COOLING_PERIOD:\n            self.is_eligible = False\n            # print(f\"RESULT time_diff &gt; COOLING_PERIOD: {time_diff} &lt; {COOLING_PERIOD}\")\n        else:\n            self.is_eligible = True\n            # print(f\"RESULT heat_score is less than OVERHEATING_RISK and time_diff is less than COOLING_PERIOD\")\n        return self.is_eligible\n</code></pre>"},{"location":"reference/iimrp/thermal/#iimrp.thermal.MRPNoteHeatMonitor.__init__","title":"<code>__init__(midi_number)</code>","text":"<p>Constructs all the necessary attributes for the note object.</p>"},{"location":"reference/iimrp/thermal/#iimrp.thermal.MRPNoteHeatMonitor.__init__--parameters","title":"Parameters","text":"<p>midi_number : int     The MIDI number of the note.</p> Source code in <code>src/iimrp/thermal.py</code> <pre><code>def __init__(self, midi_number):\n    \"\"\"\n    Constructs all the necessary attributes for the note object.\n\n    Parameters\n    ----------\n    midi_number : int\n        The MIDI number of the note.\n    \"\"\"\n    self.start_time = time.time()\n    self.midi_number = midi_number\n    self.heat_score = 0\n    self.last_played = self.start_time\n    self.is_eligible = True\n</code></pre>"},{"location":"reference/iimrp/thermal/#iimrp.thermal.MRPNoteHeatMonitor.calculate_harmonics_score","title":"<code>calculate_harmonics_score(harmonics_array)</code>","text":"<p>Calculate the harmonics score based on the given array of harmonics.</p>"},{"location":"reference/iimrp/thermal/#iimrp.thermal.MRPNoteHeatMonitor.calculate_harmonics_score--parameters","title":"Parameters","text":"<p>harmonics_array : numpy.array     The array of harmonics being played.</p>"},{"location":"reference/iimrp/thermal/#iimrp.thermal.MRPNoteHeatMonitor.calculate_harmonics_score--returns","title":"Returns","text":"<p>float     The calculated harmonics score.</p> Source code in <code>src/iimrp/thermal.py</code> <pre><code>def calculate_harmonics_score(self, harmonics_array):\n    \"\"\"\n    Calculate the harmonics score based on the given array of harmonics.\n\n    Parameters\n    ----------\n    harmonics_array : numpy.array\n        The array of harmonics being played.\n\n    Returns\n    -------\n    float\n        The calculated harmonics score.\n    \"\"\"\n    return np.dot((len(harmonics_array) - np.arange(len(harmonics_array))), harmonics_array)\n</code></pre>"},{"location":"reference/iimrp/thermal/#iimrp.thermal.MRPNoteHeatMonitor.check_eligibility","title":"<code>check_eligibility(current_time=None)</code>","text":"<p>Check if the note is eligible to be played.</p>"},{"location":"reference/iimrp/thermal/#iimrp.thermal.MRPNoteHeatMonitor.check_eligibility--returns","title":"Returns","text":"<p>bool     True if the note is eligible to be played, False otherwise.</p> Source code in <code>src/iimrp/thermal.py</code> <pre><code>def check_eligibility(self, current_time=None):\n    \"\"\"\n    Check if the note is eligible to be played.\n\n    Returns\n    -------\n    bool\n        True if the note is eligible to be played, False otherwise.\n    \"\"\"\n    if current_time is None:\n        current_time = time.time()\n    time_diff = current_time - self.last_played\n    # print(f\"heat_score: {self.heat_score:.1f}, time_diff: {time_diff:.1f}\")\n    if self.heat_score &gt; OVERHEATING_RISK:\n        self.last_played = current_time + COOLING_PERIOD\n        self.is_eligible = False\n        # print(f\"RESULT self.heat_score &gt; OVERHEATING_RISK: {self.heat_score} &gt; {OVERHEATING_RISK}\")\n    elif time_diff &gt; COOLING_PERIOD:\n        self.is_eligible = False\n        # print(f\"RESULT time_diff &gt; COOLING_PERIOD: {time_diff} &lt; {COOLING_PERIOD}\")\n    else:\n        self.is_eligible = True\n        # print(f\"RESULT heat_score is less than OVERHEATING_RISK and time_diff is less than COOLING_PERIOD\")\n    return self.is_eligible\n</code></pre>"},{"location":"reference/iimrp/thermal/#iimrp.thermal.MRPNoteHeatMonitor.update_heat_score_off","title":"<code>update_heat_score_off(current_time=None)</code>","text":"<p>Update the heat score for the note when it is not being played.</p> Source code in <code>src/iimrp/thermal.py</code> <pre><code>def update_heat_score_off(self, current_time=None):\n    \"\"\"\n    Update the heat score for the note when it is not being played.\n    \"\"\"\n    if current_time is None:\n        current_time = time.time()\n    if self.heat_score &gt; 0:\n        time_diff = current_time - self.last_played\n        heat_score_prev = self.heat_score\n        self.heat_score -= HEAT_DISSIPATION * time_diff\n        heat_score_diff = self.heat_score - heat_score_prev\n        # print(f\"heat_score: {self.heat_score:.1f} heat_score_diff: {heat_score_diff:.1f} time_diff: {time_diff:.1f}\")\n        if self.heat_score &lt; 0:\n            self.heat_score = 0\n</code></pre>"},{"location":"reference/iimrp/thermal/#iimrp.thermal.MRPNoteHeatMonitor.update_heat_score_on","title":"<code>update_heat_score_on(harmonics_array, current_time=None)</code>","text":"<p>Update the heat score for the note when it is being played.</p>"},{"location":"reference/iimrp/thermal/#iimrp.thermal.MRPNoteHeatMonitor.update_heat_score_on--parameters","title":"Parameters","text":"<p>harmonics_array : numpy.array     The array of harmonics being played.</p> Source code in <code>src/iimrp/thermal.py</code> <pre><code>def update_heat_score_on(self, harmonics_array, current_time=None):\n    \"\"\"\n    Update the heat score for the note when it is being played.\n\n    Parameters\n    ----------\n    harmonics_array : numpy.array\n        The array of harmonics being played.\n    \"\"\"\n    if current_time is None:\n        current_time = time.time()\n    time_diff = current_time - self.last_played\n    heat_increase_amount = HEAT_INCREASE * time_diff\n    harmonics_scaling = HARMONICS_SCALAR * self.calculate_harmonics_score(harmonics_array)\n    # heat_score_prev = self.heat_score\n    self.heat_score += heat_increase_amount * harmonics_scaling\n    # heat_score_diff = self.heat_score - heat_score_prev\n    # print(f\"increase {heat_increase_amount:.4f} * harmonics {harmonics_scaling:.4f} = heat_score: {self.heat_score:.4f}, time_diff: {time_diff:.4f}\")\n    self.last_played = current_time\n</code></pre>"},{"location":"reference/tests/test_harmonics/","title":"Test harmonics","text":""},{"location":"reference/tests/test_thermal/","title":"Test thermal","text":""}]}